<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Viewer (High-Visibility)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --zoom: 1; }
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family: system-ui, sans-serif; -webkit-font-smoothing:antialiased; }
    /* stage and viewport use as much screen as possible */
    .stage { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; }
    .viewport { width:100%; height:100%; overflow:hidden; display:flex; align-items:center; justify-content:center; touch-action:none; }
    video#remote { width:100%; height:100%; object-fit:contain; transform-origin:center center; transform: translate(0px,0px) scale(var(--zoom)); transition: transform .06s linear; background:#000; will-change:transform; }

    /* Large centered copy button (visible until session starts) */
    .center-btn {
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      z-index:60;
      background:#0078d4;
      color:#fff;
      border:none;
      padding:28px 40px;
      font-size:30px;
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,0.6);
      cursor:pointer;
      opacity:0.98;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:14px;
      min-width:420px;
      text-align:center;
    }
    .center-btn:disabled { background:#444; cursor:not-allowed; opacity:0.9; }

    /* large persistent copied indicator */
    .copied-banner {
      position:fixed;
      left:16px;
      right:16px;
      bottom:16px;
      z-index:65;
      background:#1b5e20;
      color:#fff;
      padding:18px;
      font-size:20px;
      border-radius:10px;
      display:none;
      box-shadow:0 8px 30px rgba(0,0,0,0.6);
    }
    .copied-banner.visible { display:block; }

    /* small status in top center */
    .status {
      position:fixed;
      top:12px;
      left:50%;
      transform:translateX(-50%);
      z-index:62;
      background:rgba(0,0,0,0.6);
      color:#ffd;
      padding:8px 12px;
      border-radius:8px;
      font-size:18px;
    }

    /* hide UI when session started */
    body.session-started .center-btn,
    body.session-started .copied-banner,
    body.session-started .status { display:none !important; }

    @media (max-width:640px) {
      .center-btn { min-width:260px; padding:18px 22px; font-size:20px; border-radius:10px; }
      .status { font-size:16px; }
    }
  </style>
</head>
<body>
  <div class="stage">
    <div class="viewport" id="viewport">
      <video id="remote" autoplay playsinline></video>
    </div>
  </div>

  <div class="status" id="status" aria-live="polite">Waiting for offer in URL...</div>

  <button id="btnCopy" class="center-btn" disabled aria-live="polite">Preparing answer…</button>

  <div class="copied-banner" id="copiedBanner" role="status" aria-live="assertive">
    Copied to clipboard — send this to the sharer. Waiting for session to start...
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <script>
    const params = new URLSearchParams(location.search);
    const compressedOffer = params.get('o');
    const statusEl = document.getElementById('status');
    const remote = document.getElementById('remote');
    const viewport = document.getElementById('viewport');
    const btnCopy = document.getElementById('btnCopy');
    const copiedBanner = document.getElementById('copiedBanner');

    let pc;
    let compressedAnswer = '';
    let answerReady = false;
    let sessionStarted = false;
    let zoom = 1;

    // pan state (pixels)
    let panX = 0, panY = 0;
    let startPanX = 0, startPanY = 0;
    let pointerActive = false;
    let pointerId = null;
    let startClientX = 0, startClientY = 0;

    // base displayed size of the video (before scale)
    let baseWidth = 0, baseHeight = 0;

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function waitForIceComplete(pc, timeout = 10000) {
      return new Promise(resolve => {
        if (pc.iceGatheringState === 'complete') return resolve();
        const timer = setTimeout(() => { pc.onicecandidate = null; resolve(); }, timeout);
        pc.onicecandidate = (e) => {
          if (!e.candidate) { clearTimeout(timer); pc.onicecandidate = null; resolve(); }
        };
      });
    }

    async function buildAnswerFromOffer(comp) {
      try {
        setStatus('Parsing offer...');
        const json = LZString.decompressFromEncodedURIComponent(comp);
        if (!json) throw new Error('Failed to decompress offer.');
        const offer = JSON.parse(json);

        pc = new RTCPeerConnection();
        pc.ontrack = (evt) => {
          remote.srcObject = evt.streams[0];
        };

        setStatus('Setting remote description...');
        await pc.setRemoteDescription(offer);

        setStatus('Creating answer...');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        setStatus('Waiting for ICE candidates...');
        await waitForIceComplete(pc, 10000);

        const fullAnswer = pc.localDescription;
        const payload = JSON.stringify(fullAnswer);
        compressedAnswer = LZString.compressToEncodedURIComponent(payload);
        answerReady = true;

        btnCopy.disabled = false;
        btnCopy.textContent = 'Copy answer — send to sharer';
        setStatus('Answer ready. Copy and send it to the sharer.');
      } catch (err) {
        console.error(err);
        setStatus('Error preparing answer: ' + (err && err.message ? err.message : err));
        btnCopy.disabled = true;
        btnCopy.textContent = 'Error preparing answer';
      }
    }

    async function copyAnswer() {
      if (!answerReady || !compressedAnswer) return;
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(compressedAnswer);
        } else {
          const ta = document.createElement('textarea');
          ta.value = compressedAnswer;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
        // show persistent visible indicator
        copiedBanner.classList.add('visible');
        btnCopy.disabled = true;
        btnCopy.textContent = 'Copied — waiting for session';
        setStatus('Copied to clipboard — send it to the sharer.');
      } catch (err) {
        console.error(err);
        setStatus('Copy failed: ' + (err && err.message ? err.message : err));
      }
    }

    function onSessionStarted() {
      if (sessionStarted) return;
      sessionStarted = true;
      document.body.classList.add('session-started');
      setStatus('Session started');
    }

    // compute baseWidth/baseHeight (displayed video size before scale) using intrinsic video size and viewport
    function computeBaseSize() {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      // if intrinsic sizes available use them
      const vW = remote.videoWidth || vw;
      const vH = remote.videoHeight || vh;
      const ratio = Math.min(vw / vW, vh / vH);
      baseWidth = vW * ratio;
      baseHeight = vH * ratio;
      // if base is slightly smaller than viewport due to rounding, keep it exact
      baseWidth = Math.round(baseWidth);
      baseHeight = Math.round(baseHeight);
      // adjust pan to remain within new limits
      clampPan();
      applyTransform();
    }

    function clampPan() {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      const scaledWidth = baseWidth * zoom;
      const scaledHeight = baseHeight * zoom;
      const maxPanX = Math.max(0, (scaledWidth - vw) / 2);
      const maxPanY = Math.max(0, (scaledHeight - vh) / 2);
      panX = Math.max(-maxPanX, Math.min(maxPanX, panX));
      panY = Math.max(-maxPanY, Math.min(maxPanY, panY));
    }

    function applyTransform() {
      remote.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
      document.documentElement.style.setProperty('--zoom', zoom);
    }

    function applyZoom(v, centerClientX = null, centerClientY = null) {
      const oldZoom = zoom;
      zoom = Math.max(1, Math.min(4, v));
      // if center provided, adjust pan so zoom focuses on that point
      if (centerClientX !== null && centerClientY !== null) {
        const rect = viewport.getBoundingClientRect();
        const cx = centerClientX - rect.left - rect.width / 2; // client offset from center
        const cy = centerClientY - rect.top - rect.height / 2;
        // scale pan so that the point under cursor stays roughly under cursor
        panX = (panX - cx) * (zoom / oldZoom) + cx;
        panY = (panY - cy) * (zoom / oldZoom) + cy;
      } else {
        // scale relative to center
        panX = panX * (zoom / oldZoom);
        panY = panY * (zoom / oldZoom);
      }
      clampPan();
      applyTransform();
    }

    // pointer (mouse/touch) pan handlers
    function onPointerDown(e) {
      if (zoom <= 1) return; // no pan when not zoomed
      pointerActive = true;
      pointerId = e.pointerId;
      viewport.setPointerCapture(pointerId);
      startClientX = e.clientX;
      startClientY = e.clientY;
      startPanX = panX;
      startPanY = panY;
    }

    function onPointerMove(e) {
      if (!pointerActive || e.pointerId !== pointerId) return;
      const dx = e.clientX - startClientX;
      const dy = e.clientY - startClientY;
      panX = startPanX + dx;
      panY = startPanY + dy;
      clampPan();
      applyTransform();
    }

    function onPointerUp(e) {
      if (!pointerActive || e.pointerId !== pointerId) return;
      pointerActive = false;
      try { viewport.releasePointerCapture(pointerId); } catch {}
      pointerId = null;
    }

    // init
    (async () => {
      btnCopy.addEventListener('click', copyAnswer);

      // keyboard +/- adjust zoom
      window.addEventListener('keydown', (e) => {
        if (e.key === '+' || e.key === '=') { applyZoom(+(zoom + 0.2).toFixed(2)); }
        else if (e.key === '-') { applyZoom(+(zoom - 0.2).toFixed(2)); }
      });

      // wheel to zoom (scroll up to zoom in) - keep center under cursor
      window.addEventListener('wheel', (e) => {
        if (e.ctrlKey) return; // avoid interfering with pinch-zoom on some platforms
        if (Math.abs(e.deltaY) < 1) return;
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        applyZoom(+(zoom + delta).toFixed(2), e.clientX, e.clientY);
      }, { passive: true });

      // double-click to toggle a stronger zoom for quick readability (centered)
      viewport.addEventListener('dblclick', (ev) => {
        applyZoom(zoom < 2 ? 2.2 : 1, ev.clientX, ev.clientY);
      });

      // pointer events for pan
      viewport.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('pointercancel', onPointerUp);

      // handle resize to recalc base size and clamp pan
      window.addEventListener('resize', computeBaseSize);

      // if no offer present
      if (!compressedOffer) {
        setStatus('No offer found in URL. Use the sender link.');
        btnCopy.disabled = true;
        btnCopy.textContent = 'No offer';
        return;
      }

      setStatus('Offer found — creating answer automatically...');
      await buildAnswerFromOffer(compressedOffer);

      // when remote video has metadata we can compute base size
      remote.addEventListener('loadedmetadata', () => {
        computeBaseSize();
        // try autoplay
        remote.play().catch(()=>{});
      });

      // when remote video plays -> session started
      remote.addEventListener('playing', () => onSessionStarted());

      // if metadata never fires (some streams) fallback to compute on first frame
      remote.addEventListener('resize', computeBaseSize);

      // initial zoom (1x)
      applyZoom(1);
    })();
  </script>
</body>
</html>