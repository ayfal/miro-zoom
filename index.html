<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Sender</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; max-width: 900px; }
    textarea { width: 100%; height: 120px; font-family: monospace; }
    input[type=text] { width: 100%; }
    video { width: 48%; max-height: 360px; background: #000; }
    .row { display:flex; gap:8px; align-items:flex-start; margin-top:8px; }
    .col { flex:1; }
  </style>
</head>
<body>
  <h1>PeerSharing — Sender</h1>

  <p>This page will capture your microphone + screen, create an SDP offer and produce a compressed viewer link. Paste the viewer's compressed answer below and click "Set Answer".</p>

  <button id="btnOffer">Generate Offer & Viewer Link</button>
  <div id="status"></div>

  <h3>Viewer link (share this)</h3>
  <input type="text" id="viewerLink" readonly />

  <h3>Local / Remote preview</h3>
  <div class="row">
    <div class="col">
      <p>Local (screen)</p>
      <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div class="col">
      <p>Remote (what viewer receives)</p>
      <!-- show the outgoing screen stream (muted) so sender can see exactly what the viewer will see -->
      <video id="remoteVideo" autoplay playsinline muted></video>
    </div>
  </div>

  <h3>Paste compressed answer from viewer</h3>
  <textarea id="answerArea" placeholder="Paste compressed answer here (viewer->copy)"></textarea>
  <button id="btnSetAnswer">Set Answer & Start</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    // base64url helpers and pako wrapper (smaller output than LZ-String in many cases)
    function base64UrlEncode(u8) {
      let CHUNK = 0x8000;
      let result = '';
      for (let i = 0; i < u8.length; i += CHUNK) {
        result += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
      }
      let b64 = btoa(result);
      return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function base64UrlDecode(str) {
      str = str.replace(/-/g,'+').replace(/_/g,'/');
      while (str.length % 4) str += '=';
      const bin = atob(str);
      const len = bin.length;
      const u8 = new Uint8Array(len);
      for (let i = 0; i < len; i++) u8[i] = bin.charCodeAt(i);
      return u8;
    }
    function compressAndEncode(obj) {
      const json = JSON.stringify(obj);
      const def = pako.deflate(json);
      return base64UrlEncode(def);
    }
    function decodeAndDecompress(str) {
      const u8 = base64UrlDecode(str);
      const infl = pako.inflate(u8);
      const txt = new TextDecoder().decode(infl);
      return JSON.parse(txt);
    }

    // Minimal helper: wait for ICE gathering to finish (onicecandidate null indicates done)
    function waitForIceComplete(pc, timeout = 10000) {
      return new Promise((resolve, reject) => {
        if (pc.iceGatheringState === 'complete') return resolve();
        const timer = setTimeout(() => {
          pc.onicecandidate = null;
          resolve(); // timeout: proceed anyway
        }, timeout);
        pc.onicecandidate = (e) => {
          if (!e.candidate) {
            clearTimeout(timer);
            pc.onicecandidate = null;
            resolve();
          }
        };
      });
    }

    let pc;
    let localStream;
    const btnOffer = document.getElementById('btnOffer');
    const viewerLink = document.getElementById('viewerLink');
    const status = document.getElementById('status');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const answerArea = document.getElementById('answerArea');
    const btnSetAnswer = document.getElementById('btnSetAnswer');

    btnOffer.onclick = async () => {
      try {
        status.textContent = 'Creating peer connection and gathering local media...';
        pc = new RTCPeerConnection();

        // Show remote tracks when they arrive (viewer side would show what sender sends)
        pc.ontrack = (evt) => {
          remoteVideo.srcObject = evt.streams[0];
        };

        // Get microphone + screen
        const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });

        // Combine streams: add audio tracks and screen tracks to PC, show local preview as combined stream
        localStream = new MediaStream();
        audioStream.getAudioTracks().forEach(t => { pc.addTrack(t, audioStream); localStream.addTrack(t); });
        screenStream.getVideoTracks().forEach(t => { pc.addTrack(t, screenStream); localStream.addTrack(t); });

        localVideo.srcObject = localStream;
        // Show the outgoing screen on the "remote" preview so the sender sees what the viewer will see
        remoteVideo.srcObject = screenStream;
        remoteVideo.muted = true;

        // Create offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        status.textContent = 'Waiting for ICE gathering to complete...';
        await waitForIceComplete(pc, 10000);

        // Use the finalized localDescription
        const fullOffer = pc.localDescription;
        const compressed = compressAndEncode(fullOffer);
        // Build viewer URL (viewer.html in same folder) — use URL() so it works reliably
        const urlObj = new URL('viewer.html', window.location.href);
        urlObj.searchParams.set('o', compressed);
        viewerLink.value = urlObj.href;

        // copy the viewer link to clipboard (with fallback)
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(urlObj.href);
            status.textContent = 'Offer ready. Viewer link copied to clipboard.';
          } else {
            const ta = document.createElement('textarea');
            ta.value = urlObj.href;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            status.textContent = 'Offer ready. Viewer link copied to clipboard (fallback).';
          }
        } catch (copyErr) {
          console.warn('Clipboard copy failed', copyErr);
          status.textContent = 'Offer ready. Could not copy link — please copy manually.';
        }
      } catch (err) {
        console.error(err);
        status.textContent = 'Error: ' + err;
      }
    };

    btnSetAnswer.onclick = async () => {
      if (!pc) {
        status.textContent = 'No peer connection. Generate an offer first.'; 
        return;
      }
      const compressed = answerArea.value.trim();
      if (!compressed) { status.textContent = 'Paste compressed answer first.'; return; }
      try {
        status.textContent = 'Decoding answer and setting remote description...';
        const json = LZString.decompressFromEncodedURIComponent(compressed);
        if (!json) throw new Error('Failed to decompress answer.');
        const answer = JSON.parse(json);
        await pc.setRemoteDescription(answer);
        status.textContent = 'Remote description set. Connection should establish when tracks arrive.';
      } catch (err) {
        console.error(err);
        status.textContent = 'Error: ' + err;
      }
    };
  </script>
</body>
</html>