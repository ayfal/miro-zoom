<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Sender</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; max-width: 900px; }
    textarea { width: 100%; height: 120px; font-family: monospace; }
    input[type=text] { width: 100%; }
    video { width: 100%; max-height: 80vh; background: #000; display:block; }
    .row { display:block; margin-top:8px; }
    .col { margin-bottom:12px; }
  </style>
</head>
<body>
  <h1>PeerSharing — Sender</h1>

  <p>This page will capture your microphone + screen, create an SDP offer and produce a compressed viewer link. Paste the viewer's compressed answer below and click "Set Answer".</p>

  <!-- New flow: enable media first, then generate offer (so clipboard copy works reliably) -->
  <button id="btnEnableMedia">Enable screen & microphone</button>
  <button id="btnOffer" disabled>Generate Offer & Viewer Link</button>
  <div id="status"></div>

  <h3>Viewer link (share this)</h3>
  <input type="text" id="viewerLink" readonly />

  <!-- renamed and clarified: Session indicator appears only after session starts -->
  <h3 id="previewTitle">Session indicator — appears after session starts</h3>
  <div class="row">
    <div class="col">
      <video id="localVideo" autoplay playsinline muted aria-label="Session indicator visible to viewer"></video>
    </div>
  </div>

  <h3>Paste compressed answer from viewer</h3>
  <textarea id="answerArea" placeholder="Paste compressed answer here (viewer->copy)"></textarea>
  <button id="btnSetAnswer">Set Answer & Start</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <script>
    // ICE / STUN config helper — add additional STUN/TURN servers here
    function getIceConfig() {
      return {
        iceServers: [
          { urls: [ 'stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302' ] }
          // Example TURN entry (requires username & credential):
          // { urls: 'turn:your.turn.server:3478', username: 'user', credential: 'pass' }
        ]
      };
    }

    function waitForIceComplete(pc, timeout = 10000) {
      return new Promise((resolve, reject) => {
        if (pc.iceGatheringState === 'complete') return resolve();
        const timer = setTimeout(() => {
          pc.onicecandidate = null;
          resolve();
        }, timeout);
        pc.onicecandidate = (e) => {
          if (!e.candidate) {
            clearTimeout(timer);
            pc.onicecandidate = null;
            resolve();
          }
        };
      });
    }

    let pc = null;
    let localStream = null;
    let screenStreamGlobal = null;
    let previewVisible = false;
    let mediaEnabled = false;

    const btnEnableMedia = document.getElementById('btnEnableMedia');
    const btnOffer = document.getElementById('btnOffer');
    const viewerLink = document.getElementById('viewerLink');
    const status = document.getElementById('status');
    const localVideo = document.getElementById('localVideo');
    const answerArea = document.getElementById('answerArea');
    const btnSetAnswer = document.getElementById('btnSetAnswer');
    const previewTitle = document.getElementById('previewTitle');

    function showPreviewIfReady() {
      if (previewVisible) return;
      if (!screenStreamGlobal) return;
      // attach only the screen track(s) so the preview matches what viewer sees
      localVideo.srcObject = screenStreamGlobal;
      localVideo.muted = true;
      previewVisible = true;
      previewTitle.textContent = 'Sent preview — visible to viewer (active)';
    }

    // Clear the session indicator (blank the preview shown to the sharer)
    function clearSessionIndicator() {
      try {
        if (localVideo.srcObject) {
          localVideo.srcObject = null;
        }
        localVideo.pause();
        try { localVideo.removeAttribute('src'); } catch {}
        try { localVideo.load(); } catch {}
      } catch (e) { /* ignore */ }
      previewVisible = false;
      previewTitle.textContent = 'Session indicator — appears after session starts';
      status.textContent = 'Viewer disconnected — session ended';
    }
    
    btnEnableMedia.onclick = async () => {
      try {
        status.textContent = 'Requesting screen & microphone permission...';
        // create pc now so tracks can be added without further permission prompts later
        if (!pc) pc = new RTCPeerConnection(getIceConfig());

        const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });

        screenStreamGlobal = screenStream;
        localStream = new MediaStream();
        audioStream.getAudioTracks().forEach(t => { pc.addTrack(t, audioStream); localStream.addTrack(t); });
        screenStream.getVideoTracks().forEach(t => { pc.addTrack(t, screenStream); localStream.addTrack(t); });

        // DO NOT show immediate preview here — session indicator must appear only after session starts
        // localVideo.srcObject = localStream;  <-- removed so preview appears only after session is active

        mediaEnabled = true;
        btnOffer.disabled = false;
        btnEnableMedia.disabled = true;
        status.textContent = 'Media enabled. Now click "Generate Offer & Viewer Link".';
      } catch (err) {
        console.error(err);
        status.textContent = 'Media enable failed or denied: ' + (err && err.message ? err.message : err);
      }
    };

    btnOffer.onclick = async () => {
      if (!mediaEnabled || !pc) {
        status.textContent = 'Enable screen & mic first.';
        return;
      }
      try {
        status.textContent = 'Creating offer and gathering ICE...';

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        await waitForIceComplete(pc, 10000);

        const fullOffer = pc.localDescription;
        const payload = JSON.stringify(fullOffer);
        const compressed = LZString.compressToEncodedURIComponent(payload);

        const urlObj = new URL('viewer.html', window.location.href);
        urlObj.searchParams.set('o', compressed);
        viewerLink.value = urlObj.href;

        // copy the viewer link to clipboard (now inside user gesture post-permission -> should succeed)
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(urlObj.href);
            status.textContent = 'Offer ready. Viewer link copied to clipboard.';
          } else {
            const ta = document.createElement('textarea');
            ta.value = urlObj.href;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            status.textContent = 'Offer ready. Viewer link copied to clipboard (fallback).';
          }
        } catch (copyErr) {
          console.warn('Clipboard copy failed', copyErr);
          status.textContent = 'Offer ready. Could not copy link — please copy manually from the field.';
        }
      } catch (err) {
        console.error(err);
        status.textContent = 'Error creating offer: ' + (err && err.message ? err.message : err);
      }
    };

    btnSetAnswer.onclick = async () => {
      if (!pc) { status.textContent = 'No peer connection. Enable media first.'; return; }
      const compressed = answerArea.value.trim();
      if (!compressed) { status.textContent = 'Paste compressed answer first.'; return; }
      try {
        status.textContent = 'Decoding answer and setting remote description...';
        const json = LZString.decompressFromEncodedURIComponent(compressed);
        if (!json) throw new Error('Failed to decompress answer.');
        const answer = JSON.parse(json);
        await pc.setRemoteDescription(answer);
        status.textContent = 'Remote description set. Waiting for connection...';

        // react to connection / ice state changes: show preview when connected, clear when disconnected/failed/closed
        pc.addEventListener('connectionstatechange', () => {
          const s = pc.connectionState;
          if (s === 'connected' || s === 'completed') {
            showPreviewIfReady();
            status.textContent = 'Session active — preview visible to viewer';
          } else if (s === 'disconnected' || s === 'failed' || s === 'closed') {
            clearSessionIndicator();
          }
        });
        pc.addEventListener('iceconnectionstatechange', () => {
          const s = pc.iceConnectionState;
          if (s === 'connected' || s === 'completed') {
            showPreviewIfReady();
            status.textContent = 'Session active — preview visible to viewer';
          } else if (s === 'disconnected' || s === 'failed' || s === 'closed') {
            clearSessionIndicator();
          }
        });
 
        setTimeout(() => {
          if (!previewVisible) {
            if (pc.connectionState === 'connected' || pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
              showPreviewIfReady();
              status.textContent = 'Session active — preview visible to viewer';
            }
          }
        }, 250);
      } catch (err) {
        console.error(err);
        status.textContent = 'Error: ' + err;
      }
    };
  </script>
</body>
</html>