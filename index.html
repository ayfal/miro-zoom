<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Sender</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; max-width: 900px; }
    textarea { width: 100%; height: 120px; font-family: monospace; }
    input[type=text] { width: 100%; }
    video { width: 100%; max-height: 80vh; background: #000; display:block; }
    .row { display:block; margin-top:8px; }
    .col { margin-bottom:12px; }
  </style>
</head>
<body>
  <h1>PeerSharing — Sender</h1>

  <p>This page will capture your microphone + screen, create an SDP offer and produce a compressed viewer link. Paste the viewer's compressed answer below and click "Set Answer".</p>

  <button id="btnOffer">Generate Offer & Viewer Link</button>
  <div id="status"></div>

  <h3>Viewer link (share this)</h3>
  <input type="text" id="viewerLink" readonly />

  <h3 id="previewTitle">Sent preview — visible to viewer (appears after session starts)</h3>
  <div class="row">
    <div class="col">
      <video id="localVideo" autoplay playsinline muted aria-label="Preview visible to viewer"></video>
    </div>
  </div>

  <h3>Paste compressed answer from viewer</h3>
  <textarea id="answerArea" placeholder="Paste compressed answer here (viewer->copy)"></textarea>
  <button id="btnSetAnswer">Set Answer & Start</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <script>
    // Minimal helper: wait for ICE gathering to finish (onicecandidate null indicates done)
    function waitForIceComplete(pc, timeout = 10000) {
      return new Promise((resolve, reject) => {
        if (pc.iceGatheringState === 'complete') return resolve();
        const timer = setTimeout(() => {
          pc.onicecandidate = null;
          resolve(); // timeout: proceed anyway
        }, timeout);
        pc.onicecandidate = (e) => {
          if (!e.candidate) {
            clearTimeout(timer);
            pc.onicecandidate = null;
            resolve();
          }
        };
      });
    }

    let pc;
    let localStream;
    let screenStreamGlobal = null; // keep screen stream to attach after session starts
    let previewVisible = false;
    const btnOffer = document.getElementById('btnOffer');
    const viewerLink = document.getElementById('viewerLink');
    const status = document.getElementById('status');
    const localVideo = document.getElementById('localVideo');
    const answerArea = document.getElementById('answerArea');
    const btnSetAnswer = document.getElementById('btnSetAnswer');
    const previewTitle = document.getElementById('previewTitle');

    function showPreviewIfReady() {
      if (previewVisible) return;
      if (!screenStreamGlobal) return;
      // attach only the screen track(s) so the preview matches what viewer sees
      localVideo.srcObject = screenStreamGlobal;
      localVideo.muted = true;
      previewVisible = true;
      previewTitle.textContent = 'Sent preview — visible to viewer (active)';
    }

    btnOffer.onclick = async () => {
      try {
        status.textContent = 'Creating peer connection and gathering local media...';
        pc = new RTCPeerConnection();

        // Get microphone + screen
        const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        screenStreamGlobal = screenStream; // store for later preview (only shown after session start)

        // Combine streams: add audio tracks and screen tracks to PC, show local preview only after session
        localStream = new MediaStream();
        audioStream.getAudioTracks().forEach(t => { pc.addTrack(t, audioStream); localStream.addTrack(t); });
        screenStream.getVideoTracks().forEach(t => { pc.addTrack(t, screenStream); localStream.addTrack(t); });

        // NOTE: do not set localVideo.srcObject here — preview must appear only after session start

        // Create offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        status.textContent = 'Waiting for ICE gathering to complete...';
        await waitForIceComplete(pc, 10000);

        // Use the finalized localDescription
        const fullOffer = pc.localDescription;
        const payload = JSON.stringify(fullOffer);
        const compressed = LZString.compressToEncodedURIComponent(payload);

        // Build viewer URL (viewer.html in same folder) — use URL() so it works reliably
        const urlObj = new URL('viewer.html', window.location.href);
        urlObj.searchParams.set('o', compressed);
        viewerLink.value = urlObj.href;

        // copy the viewer link to clipboard (with fallback)
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(urlObj.href);
            status.textContent = 'Offer ready. Viewer link copied to clipboard.';
          } else {
            const ta = document.createElement('textarea');
            ta.value = urlObj.href;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            status.textContent = 'Offer ready. Viewer link copied to clipboard (fallback).';
          }
        } catch (copyErr) {
          console.warn('Clipboard copy failed', copyErr);
          status.textContent = 'Offer ready. Could not copy link — please copy manually.';
        }
      } catch (err) {
        console.error(err);
        status.textContent = 'Error: ' + err;
      }
    };

    btnSetAnswer.onclick = async () => {
      if (!pc) {
        status.textContent = 'No peer connection. Generate an offer first.'; 
        return;
      }
      const compressed = answerArea.value.trim();
      if (!compressed) { status.textContent = 'Paste compressed answer first.'; return; }
      try {
        status.textContent = 'Decoding answer and setting remote description...';
        const json = LZString.decompressFromEncodedURIComponent(compressed);
        if (!json) throw new Error('Failed to decompress answer.');
        const answer = JSON.parse(json);
        await pc.setRemoteDescription(answer);
        status.textContent = 'Remote description set. Waiting for connection...';

        // when peer connection becomes connected/completed show the sent preview
        pc.addEventListener('connectionstatechange', () => {
          if (pc.connectionState === 'connected' || pc.connectionState === 'completed') {
            showPreviewIfReady();
            status.textContent = 'Session active — preview visible to viewer';
          }
        });

        // ICE state fallback
        pc.addEventListener('iceconnectionstatechange', () => {
          if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
            showPreviewIfReady();
            status.textContent = 'Session active — preview visible to viewer';
          }
        });

        // also attempt to show preview immediately after setting remote description if possible
        setTimeout(() => {
          if (!previewVisible) {
            // if the connection seems ready, show preview
            if (pc.connectionState === 'connected' || pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
              showPreviewIfReady();
              status.textContent = 'Session active — preview visible to viewer';
            }
          }
        }, 250);
      } catch (err) {
        console.error(err);
        status.textContent = 'Error: ' + err;
      }
    };
  </script>
</body>
</html>