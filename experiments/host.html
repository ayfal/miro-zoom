<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Host</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{--bg:#0b0b0b;--fg:#f8f8f2;--accent:#ffcc00;}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;}
    #container{display:flex;flex-direction:column;height:100%;gap:10px;padding:12px;}
    .center{display:flex;align-items:center;justify-content:center;}
    #startBtn{font-size:20px;padding:14px 24px;border-radius:12px;border:4px solid var(--accent);background:var(--fg);color:var(--bg);cursor:pointer}
    #status{font-size:16px;padding:12px;border-radius:8px;background:#111;min-height:56px;white-space:pre-wrap;overflow:auto;}
    #previewFrame{flex:1;background:#000;border:4px solid #222;display:flex;align-items:center;justify-content:center;position:relative;}
    video#preview{max-width:100%;max-height:100%;border:2px solid #333;box-shadow:0 0 12px rgba(0,0,0,0.5);}
    #controls{display:flex;gap:8px;justify-content:center;padding:8px;}
    button.action{font-size:16px;padding:8px 12px;border-radius:8px;border:2px solid var(--accent);background:var(--bg);color:var(--fg);cursor:pointer}
    button.danger{border-color:#ff4444;color:#ffdddd}
    #smallNote{font-size:12px;color:#999;padding:4px 0;}
    @media (prefers-contrast: more){#startBtn{border-color:#fff}}
  </style>
</head>
<body>
  <div id="container">
    <div class="center">
      <button id="startBtn" aria-label="Start session as host">Start Session (Host)</button>
    </div>

    <div id="status" aria-live="polite">Ready.</div>

    <div id="previewFrame" aria-hidden="false">
      <div id="previewWrapper" class="center">
        <video id="preview" autoplay muted playsinline></video>
      </div>
    </div>

    <div id="controls" aria-hidden="true">
      <button id="muteBtn" class="action">Mute</button>
      <button id="endBtn" class="action danger">End Session</button>
    </div>

    <div id="smallNote">Signaling via PeerJS — host id: "unique-studyroom-for-host-and-visually-impaired"</div>
  </div>

  <script>
    (function(){
      const HOST_ID = "unique-studyroom-for-host-and-visually-impaired";
      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelay", credential: "openrelay" }
      ];
      const RETRY_DELAY_MS = 3000;

      let peer = null;
      let hostStream = null;
      let currentPC = null;
      let currentDC = null;
      let debugLogs = [];
      function dbg(...args){
        const t = new Date().toISOString();
        const msg = `[${t}] ${args.map(a=> (typeof a==='object'?JSON.stringify(a):a)).join(' ')}`;
        debugLogs.push(msg);
        console.log(msg);
        updateStatus(msg);
      }
      window.getDebugLogs = () => debugLogs.join('\n');

      const startBtn = document.getElementById('startBtn');
      const statusEl = document.getElementById('status');
      const preview = document.getElementById('preview');
      const controls = document.getElementById('controls');
      const muteBtn = document.getElementById('muteBtn');
      const endBtn = document.getElementById('endBtn');

      function updateStatus(txt){
        statusEl.textContent = txt;
      }

      async function getHostMedia(){
        updateStatus('Requesting screen capture & microphone permission...');
        dbg('requesting media: getDisplayMedia & getUserMedia (mic)');
        try {
          const screen = await navigator.mediaDevices.getDisplayMedia({video:true, audio:false});
          const mic = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
          const out = new MediaStream([
            ...screen.getVideoTracks(),
            ...mic.getAudioTracks()
          ]);
          dbg('media acquired', {videoTracks: screen.getVideoTracks().length, audioTracks: mic.getAudioTracks().length});
          return out;
        } catch (err){
          dbg('media permission denied or error', err && err.message);
          throw err;
        }
      }

      function attachPreview(stream){
        preview.srcObject = stream;
      }

      function initPeerWithRetry(){
        dbg('attempting to create Peer with fixed id', HOST_ID);
        updateStatus('Creating Peer with id "'+HOST_ID+'" ... (retrying if taken)');
        tryCreatePeer().catch(e=> {
          dbg('fatal peer creation error', e && e.message);
          updateStatus('Error creating peer: '+(e && e.message));
        });
      }

      function makePeer(){
        const p = new Peer(HOST_ID, {
          debug: 2,
          config: { iceServers: ICE_SERVERS }
        });
        return p;
      }

      async function tryCreatePeer(){
        let attempt = 0;
        while (true){
          attempt++;
          dbg('peer create attempt #' + attempt);
          updateStatus('Peer creation attempt #' + attempt + ' ...');
          try {
            peer = makePeer();
            await new Promise((resolve, reject) => {
              const onOpen = (id) => {
                dbg('peer open', id);
                peer.off('error', onError);
                resolve();
              };
              const onError = (err) => {
                dbg('peer error event', err && (err.type || err.message));
                peer.off('open', onOpen);
                reject(err);
              };
              peer.once('open', onOpen);
              peer.once('error', onError);

              // accept incoming data connections for SDP signaling
              peer.on('connection', dc => {
                dbg('incoming data connection from', dc.peer);
                setupDataConnection(dc);
              });
            });
            break;
          } catch (err){
            const msg = err && (err.type || err.message || err);
            dbg('peer create failed', msg);
            try { peer && peer.destroy(); } catch(e){}
            const isTaken = (err && (err.type === 'unavailable-id' || /taken/i.test(err.message || '')));
            if (isTaken){
              updateStatus('ID taken. Retrying in ' + (RETRY_DELAY_MS/1000) + 's ... (ID "'+HOST_ID+'")');
              dbg('id taken, will retry after delay');
              await new Promise(r => setTimeout(r, RETRY_DELAY_MS));
              continue;
            } else {
              throw err;
            }
          }
        }
        dbg('peer creation succeeded, now waiting for incoming viewer DataConnections');
        updateStatus('Peer ready. Waiting for viewer to connect to id "'+HOST_ID+'"...');
      }

      function playRemoteAudio(stream){
        const audio = document.createElement('audio');
        audio.autoplay = true;
        audio.srcObject = stream;
        audio.play().catch(e => dbg('audio play error', e && e.message));
      }

      function setupDataConnection(dc){
        // If there's already a connected viewer, close previous.
        if (currentDC && currentDC.peer !== dc.peer) {
          dbg('another viewer attempted to connect; closing previous connection');
          try { currentDC.close(); } catch(e){}
          try { currentPC && currentPC.close(); } catch(e){}
          currentDC = null;
          currentPC = null;
        }
        currentDC = dc;

        dc.on('open', () => {
          dbg('data connection open with viewer', dc.peer);
          updateStatus('Viewer connected (signaling). Waiting for offer...');
        });

        dc.on('data', async (msg) => {
          dbg('data from viewer', msg && msg.type);
          if (!msg || !msg.type) return;
          try {
            if (msg.type === 'offer') {
              // Create RTCPeerConnection and answer
              dbg('received SDP offer, creating RTCPeerConnection to answer');
              if (currentPC) {
                dbg('closing existing PC before creating new one');
                try { currentPC.close(); } catch(e){}
              }
              const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
              currentPC = pc;

              // Add host tracks before setting remote description
              if (!hostStream) {
                dbg('hostStream missing when offer arrived; attempting to reacquire');
                try {
                  hostStream = await getHostMedia();
                  attachPreview(hostStream);
                } catch(e){
                  dbg('failed to acquire media while handling offer', e && e.message);
                  dc.send({ type: 'error', message: 'Host media unavailable: ' + (e && e.message) });
                  return;
                }
              }
              dbg('adding host tracks to pc', {video: hostStream.getVideoTracks().length, audio: hostStream.getAudioTracks().length});
              hostStream.getTracks().forEach(track => pc.addTrack(track, hostStream));

              pc.onicecandidate = (ev) => {
                if (ev.candidate) {
                  dbg('sending ICE candidate to viewer');
                  // send serializable candidate object
                  dc.send({type:'candidate', candidate: ev.candidate.toJSON()});
                }
              };

              pc.ontrack = (ev) => {
                dbg('host pc ontrack (viewer audio?)', {tracks: ev.streams[0] && ev.streams[0].getAudioTracks().length});
                // play remote audio (viewer mic)
                playRemoteAudio(ev.streams[0]);
                updateStatus('Viewer audio receiving. Session established.');
                setTimeout(()=> updateStatus(''), 800);
                controls.setAttribute('aria-hidden','false');
              };

              // set remote description from the plain object received (msg.sdp)
              await pc.setRemoteDescription(msg.sdp);
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              dbg('sending SDP answer to viewer');
              // send serializable SDP (plain object)
              dc.send({ type:'answer', sdp: pc.localDescription.toJSON() });
            } else if (msg.type === 'candidate') {
              if (currentPC && msg.candidate) {
                dbg('adding received candidate to pc');
                try {
                  // msg.candidate is plain object -> add directly
                  await currentPC.addIceCandidate(msg.candidate);
                } catch (e){
                  dbg('addIceCandidate error', e && e.message);
                }
              } else dbg('no pc to add candidate to or invalid candidate');
            } else if (msg.type === 'hangup') {
              dbg('viewer requested hangup');
              try { currentPC && currentPC.close(); } catch(e){}
              try { currentDC && currentDC.close(); } catch(e){}
              currentPC = null;
              currentDC = null;
              updateStatus('Viewer disconnected.');
              controls.setAttribute('aria-hidden','true');
            }
          } catch (err){
            dbg('error handling data message', err && err.message);
          }
        });

        dc.on('close', () => {
          dbg('data connection closed by viewer');
          try { currentPC && currentPC.close(); } catch(e){}
          currentPC = null;
          currentDC = null;
          updateStatus('Viewer disconnected.');
          controls.setAttribute('aria-hidden','true');
        });

        dc.on('error', (e) => {
          dbg('data connection error', e && (e.message || e));
        });
      }

      startBtn.addEventListener('click', async function(){
        startBtn.disabled = true;
        try {
          hostStream = await getHostMedia();
          attachPreview(hostStream);
          dbg('preview attached');
          updateStatus('Media ready. Creating Peer and listening for viewer...');
          initPeerWithRetry();
        } catch (err){
          dbg('could not get media', err && err.message);
          updateStatus('Could not get required media: ' + (err && err.message));
          startBtn.disabled = false;
        }
      });

      muteBtn.addEventListener('click', ()=>{
        if (!hostStream) return;
        const audioTracks = hostStream.getAudioTracks();
        if (!audioTracks.length) return;
        const enabled = audioTracks[0].enabled;
        audioTracks.forEach(t => t.enabled = !enabled);
        muteBtn.textContent = enabled ? 'Unmute' : 'Mute';
        dbg('host mic ' + (enabled ? 'muted' : 'unmuted'));
      });

      endBtn.addEventListener('click', ()=>{
        dbg('end session requested by host');
        updateStatus('Ending session...');
        try { currentDC && currentDC.send({type:'hangup'}); } catch(e){}
        try { currentPC && currentPC.close(); } catch(e){}
        try { currentDC && currentDC.close(); } catch(e){}
        try { peer && peer.destroy(); dbg('peer destroyed'); } catch(e){}
        try { hostStream && hostStream.getTracks().forEach(t=>t.stop()); dbg('host tracks stopped'); } catch(e){}
        controls.setAttribute('aria-hidden','true');
        preview.srcObject = null;
        startBtn.disabled = false;
        updateStatus('Session ended. Ready.');
      });

      window.addEventListener('beforeunload', ()=>{
        try { currentPC && currentPC.close(); } catch(e){}
        try { currentDC && currentDC.close(); } catch(e){}
        try { peer && peer.destroy(); } catch(e){}
        try { hostStream && hostStream.getTracks().forEach(t=>t.stop()); } catch(e){}
      });

      updateStatus('Ready. Press Start Session to begin.\nHost will share screen and mic. Viewer will connect using fixed id.');
      dbg('host page loaded');
    })();
  </script>
</body>
</html>