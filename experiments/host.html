<!-- Minimal tailored host page for PeerJS-based signaling with fixed id.
     - Fixed Peer ID: "unique-studyroom-for-host-and-visually-impaired"
     - Retries if the ID is taken
     - Uses Google STUN and openrelay TURN
     - Shares screen + mic
     - Shows a frame of what the viewer sees, mute/unmute, end session
     - Detailed status messages and debug log capture via window.getHostDebugLogs()
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Host — PeerSharing</title>
<style>
  :root{
    --bg:#0b0b0b; --fg:#f4f4f4; --accent:#ffcc00;
  }
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;}
  body{background:var(--bg);color:var(--fg);display:flex;flex-direction:column;gap:12px;padding:16px;}
  #controls{display:flex;gap:12px;align-items:center;}
  button{background:var(--accent);color:#000;border:none;padding:10px 14px;border-radius:8px;font-weight:700;cursor:pointer;}
  #statusBox{background:#111;padding:12px;border-radius:8px;min-height:48px;flex:1;overflow:auto;}
  #previewFrame{width:420px;height:236px;background:#222;border-radius:6px;overflow:hidden;display:flex;align-items:center;justify-content:center;}
  video{width:100%;height:100%;object-fit:contain;background:#000;}
  #bigStatus{font-size:16px;font-weight:700;}
  #mutebtn,#endbtn{padding:8px 10px;}
  @media(max-width:700px){ #previewFrame{width:100%;height:200px;} }
</style>
</head>
<body>
  <h1>Host — PeerSharing</h1>

  <div id="controls">
    <button id="startBtn">Start session (share screen + mic)</button>
    <div id="previewFrame" aria-live="polite">
      <span id="previewPlaceholder">Preview (what viewer will see)</span>
      <video id="previewVideo" autoplay playsinline muted style="display:none"></video>
    </div>
    <div>
      <div style="display:flex;gap:8px;margin-bottom:8px;">
        <button id="mutebtn" disabled>Mute mic</button>
        <button id="endbtn" disabled>End session</button>
      </div>
      <div id="bigStatus" aria-live="polite">Idle</div>
    </div>
  </div>

  <div id="statusBox" aria-live="polite"></div>

  <!-- Hidden audio element to play viewer mic -->
  <audio id="viewerAudio" autoplay></audio>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    // Debug log capture for host
    (function(){
      const logs = [];
      function log(...args){
        const str = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
        const time = new Date().toISOString();
        const entry = `[HOST ${time}] ${str}`;
        logs.push(entry);
        console.log(entry);
        const box = document.getElementById('statusBox');
        const big = document.getElementById('bigStatus');
        box.innerText = logs.slice(-20).join('\n');
        big.innerText = str;
      }
      window.hostLog = log;
      window.getHostDebugLogs = () => logs.join('\n');
      // Note: in devtools you can use copy(window.getHostDebugLogs())
    })();

    const FIXED_ID = "unique-studyroom-for-host-and-visually-impaired";
    const ICE_SERVERS = [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "turn:openrelay.metered.ca:443", username: "openrelay", credential: "openrelay" }
    ];

    let peer = null;
    let hostStream = null;
    let viewerCall = null;
    let retryTimer = null;
    let isMuted = false;

    const startBtn = document.getElementById('startBtn');
    const muteBtn = document.getElementById('mutebtn');
    const endBtn = document.getElementById('endbtn');
    const previewVideo = document.getElementById('previewVideo');
    const previewPlaceholder = document.getElementById('previewPlaceholder');
    const viewerAudio = document.getElementById('viewerAudio');

    startBtn.addEventListener('click', startSession);
    muteBtn.addEventListener('click', toggleMute);
    endBtn.addEventListener('click', endSession);

    async function startSession(){
      startBtn.disabled = true;
      try {
        hostLog('USER ACTION: startSession: requesting screen & mic permissions...');
        // Request screen and mic separately and merge
        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true }).catch(e => {
          hostLog('getDisplayMedia error:', e);
          throw e;
        });
        const micStream = await navigator.mediaDevices.getUserMedia({ audio: true }).catch(e => {
          hostLog('getUserMedia (mic) error:', e);
          throw e;
        });

        // Combine tracks (prefer mic for microphone audio)
        hostStream = new MediaStream([
          ...screenStream.getVideoTracks(),
          ...micStream.getAudioTracks()
        ]);
        hostLog('Obtained hostStream, tracks:', hostStream.getTracks().map(t => t.kind+'('+t.id+')'));
        // Show preview for host
        previewPlaceholder.style.display = 'none';
        previewVideo.style.display = 'block';
        previewVideo.srcObject = hostStream;
        previewVideo.muted = true;

        muteBtn.disabled = false;
        endBtn.disabled = false;

        initPeerWithRetry();
      } catch (err) {
        hostLog('startSession failed:', err);
        startBtn.disabled = false;
      }
    }

    function initPeerWithRetry(){
      hostLog('initPeerWithRetry: creating Peer with fixed id:', FIXED_ID);
      // If there's an existing peer, destroy it first
      if(peer && !peer.destroyed){
        try{ peer.destroy(); } catch(e){ hostLog('error destroying previous peer', e); }
      }
      // Create Peer with fixed id and ICE servers
      peer = new Peer(FIXED_ID, {
        host: '0.peerjs.com',
        port: 443,
        path: '/',
        secure: true,
        config: { iceServers: ICE_SERVERS },
        debug: 2
      });

      peer.on('open', id => {
        hostLog('Peer open with id:', id);
        window.currentHostPeerId = id;
      });

      peer.on('error', err => {
        hostLog('Peer error event:', err && (err.type || err.message || err));
        // Common message when id is already taken varies. We'll retry on any error that prevents usage.
        // If ID is taken / unavailable, schedule retry loop.
        const msg = (err && (err.message || '')).toLowerCase();
        if(msg.includes('could not connect to peer') || msg.includes('id already taken') || msg.includes('unavailable') || msg.includes('already exists')){
          hostLog('Peer id appears unavailable. Will retry in 3000ms');
          scheduleRetry();
        } else {
          // For other errors, also attempt retry but slower
          hostLog('Peer error (non-specific). Will retry in 5000ms');
          scheduleRetry(5000);
        }
      });

      peer.on('disconnected', () => {
        hostLog('Peer disconnected event. Scheduling retry...');
        scheduleRetry(3000);
      });

      peer.on('close', () => {
        hostLog('Peer close event.');
      });

      // Incoming call from viewer (viewer will call the fixed id)
      peer.on('call', incomingCall => {
        hostLog('Incoming call from viewer:', incomingCall.peer);
        // Answer with hostStream (screen + mic)
        try {
          incomingCall.answer(hostStream);
          hostLog('Answered incoming call with hostStream.');
        } catch (e) {
          hostLog('Failed to answer call:', e);
        }
        setupCallHandlers(incomingCall);
      });
    }

    function scheduleRetry(ms = 3000){
      if(retryTimer) clearTimeout(retryTimer);
      retryTimer = setTimeout(() => {
        hostLog('Retry timer triggered. Re-initializing peer...');
        initPeerWithRetry();
      }, ms);
    }

    function setupCallHandlers(call){
      // Clean up previous call if any
      if(viewerCall && viewerCall.close){
        try { viewerCall.close(); } catch(e){ hostLog('Error closing previous call', e); }
      }
      viewerCall = call;
      hostLog('setupCallHandlers: binding events for call:', call.peer);

      call.on('stream', remoteStream => {
        hostLog('Received remote stream from viewer (likely their mic). Tracks:', remoteStream.getTracks().map(t=>t.kind+'('+t.id+')'));
        // Play viewer mic locally for host to hear
        viewerAudio.srcObject = remoteStream;
      });

      call.on('close', () => {
        hostLog('Call closed by remote peer');
        viewerAudio.srcObject = null;
      });

      call.on('error', err => {
        hostLog('Call error:', err);
      });
    }

    function toggleMute(){
      if(!hostStream) return;
      const audioTracks = hostStream.getAudioTracks();
      if(audioTracks.length === 0) {
        hostLog('No audio tracks to toggle.');
        return;
      }
      isMuted = !isMuted;
      audioTracks.forEach(t => t.enabled = !isMuted);
      muteBtn.textContent = isMuted ? 'Unmute mic' : 'Mute mic';
      hostLog('Mic toggled. isMuted=', isMuted);
    }

    function endSession(){
      hostLog('End session requested by host.');
      try {
        // Close call
        if(viewerCall && viewerCall.close) viewerCall.close();
        // Destroy peer
        if(peer && !peer.destroyed) peer.destroy();
        // Stop local tracks
        if(hostStream){
          hostStream.getTracks().forEach(t => {
            try{ t.stop(); } catch(e){ /* ignore */ }
          });
          hostStream = null;
        }
      } catch (e){
        hostLog('Error ending session:', e);
      } finally {
        startBtn.disabled = false;
        muteBtn.disabled = true;
        endBtn.disabled = true;
        previewVideo.srcObject = null;
        previewVideo.style.display = 'none';
        previewPlaceholder.style.display = 'block';
        document.getElementById('bigStatus').innerText = 'Session ended';
      }
    }

    // Expose minimal helper for copying logs: use copy(window.getHostDebugLogs()) from console
    hostLog('Host page loaded. Ready.');
  </script>
</body>
</html>