<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Host — Study Room</title>
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --accent:#ff0;
      --accent-contrast:#000;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:Arial,Helvetica,sans-serif; }
    .center {
      display:flex; align-items:center; justify-content:center; height:100%;
      flex-direction:column; gap:16px; padding:20px; box-sizing:border-box;
    }
    .big-button {
      font-size:36px; padding:24px 36px; border-radius:12px; border:4px solid var(--accent-contrast);
      background:var(--accent); color:var(--accent-contrast); cursor:pointer; min-width:320px; text-align:center;
      box-shadow:0 6px 0 rgba(0,0,0,0.4);
    }
    #phase { font-size:28px; text-align:center; padding:12px; border-radius:8px; background:#111; color:#fff; max-width:min(900px,95%); }
    #hostPreview { width:640px; max-width:95%; border:4px solid #222; border-radius:8px; background:#000; }
    .controls { display:flex; gap:12px; align-items:center; }
    .control-btn { font-size:20px; padding:10px 18px; border-radius:8px; cursor:pointer; }
    .hidden { display:none !important; }
    footer { position:fixed; left:8px; bottom:8px; color:#888; font-size:12px; }
  </style>
</head>
<body>
  <div class="center" id="root">
    <button id="startBtn" class="big-button" aria-label="Start session">Start Session</button>
    <div id="phase" class="hidden" role="status" aria-live="assertive"></div>

    <video id="hostPreview" autoplay muted playsinline class="hidden"></video>
    <div id="hostControls" class="controls hidden" aria-hidden="false">
      <button id="muteBtn" class="control-btn">Mute Mic</button>
      <button id="endBtn" class="control-btn">End Session</button>
    </div>
  </div>

  <footer>Host page — room id: unique-studyroom-for-host-and-visually-impaired</footer>

  <script>
    // Host logic
    (function(){
      const ROOM_ID = 'unique-studyroom-for-host-and-visually-impaired';
      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:openrelay.metered.ca:80", username: "openrelayproject", credential: "openrelayproject" },
        { urls: "turn:openrelay.metered.ca:443", username: "openrelayproject", credential: "openrelayproject" },
        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" }
      ];

      // Debug logs
      const hostLogs = [];
      function log(...args){ const t = new Date().toISOString() + ' HOST:'; hostLogs.push(t + ' ' + args.map(String).join(' ')); console.log(t, ...args); }
      window.getHostDebugLogs = () => hostLogs.join('\n');

      const startBtn = document.getElementById('startBtn');
      const phaseEl = document.getElementById('phase');
      const hostPreview = document.getElementById('hostPreview');
      const hostControls = document.getElementById('hostControls');
      const muteBtn = document.getElementById('muteBtn');
      const endBtn = document.getElementById('endBtn');

      let peer = null;
      let localStream = null;
      let viewerCall = null;
      let viewerAudioEl = null;
      let micEnabled = true;
      let running = false;

      function setPhase(text, verbose=false){
        phaseEl.textContent = text;
        phaseEl.classList.remove('hidden');
        if (verbose) log('PHASE:', text);
      }
      function clearPhase(){
        phaseEl.classList.add('hidden');
      }

      async function startSession(){
        if (running) return;
        running = true;
        startBtn.classList.add('hidden');

        setPhase('Requesting screen + microphone permissions...');
        try {
          const screenStream = await navigator.mediaDevices.getDisplayMedia({ video:true, preferCurrentTab:true });
          const micStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
          // combine both into one stream
          localStream = new MediaStream([...screenStream.getVideoTracks(), ...micStream.getAudioTracks()]);
          hostPreview.srcObject = localStream;
          hostPreview.classList.remove('hidden');
          hostControls.classList.remove('hidden');
          setPhase('Permissions granted. Initializing peer (attempting to claim room id)...', true);
          await initPeerWithRetry();
        } catch (err){
          setPhase('Permission denied or error obtaining media: ' + (err && err.message), true);
          log('Media error', err);
          startBtn.classList.remove('hidden');
          running = false;
        }
      }

      function initPeerWithRetry(){
        return new Promise((resolve, reject) => {
          let attempt=0;
          let created = false;
          function tryCreate(){
            attempt++;
            setPhase(`Creating Peer (attempt ${attempt})...`, true);
            log('Attempting to create Peer with id', ROOM_ID, 'attempt', attempt);
            try {
              peer = new Peer(ROOM_ID, { config: { iceServers: ICE_SERVERS } });
            } catch(err){
              log('Peer constructor error', err);
              setPhase('Peer initialization error: ' + (err && err.message), true);
              setTimeout(tryCreate, 2000 + Math.random()*2000);
              return;
            }

            peer.on('open', id => {
              created = true;
              setPhase('Room opened as host: ' + id, true);
              log('Peer open', id);
              resolve();
            });

            peer.on('error', err => {
              log('Peer error', err);
              // PeerJS reports id in use with type 'unavailable-id' or message contains 'taken'
              const msg = (err && (err.type || err.message || '')).toString().toLowerCase();
              if (!created && (msg.includes('unavailable-id') || msg.includes('taken') || msg.includes('id') && msg.includes('registered'))) {
                setPhase('Room id already taken. Retrying in a moment...', true);
                peer.destroy && peer.destroy();
                peer = null;
                setTimeout(tryCreate, 1500 + Math.random()*2000);
                return;
              }
              setPhase('Peer error: ' + (err && err.message), true);
            });

            peer.on('call', incomingCall => {
              log('Incoming call from', incomingCall.peer);
              setPhase('Incoming connection from viewer: ' + incomingCall.peer, true);
              // answer with local media (screen + mic)
              incomingCall.answer(localStream);
              viewerCall = incomingCall;

              incomingCall.on('stream', remoteStream => {
                log('Received remote stream (viewer audio?)');
                // attach viewer audio playback for host to hear their mic
                if (!viewerAudioEl){
                  viewerAudioEl = document.createElement('audio');
                  viewerAudioEl.autoplay = true;
                  viewerAudioEl.controls = false;
                  viewerAudioEl.style.display = 'none';
                  document.body.appendChild(viewerAudioEl);
                }
                viewerAudioEl.srcObject = remoteStream;
                setPhase('Viewer connected. Exchanging media...', true);

                // Final established: remove phase messages after small timeout to indicate connected
                setTimeout(() => {
                  clearPhase();
                }, 1000);
              });

              incomingCall.on('close', () => {
                log('Viewer call closed');
                setPhase('Viewer disconnected', true);
              });

              incomingCall.on('error', e => {
                log('Viewer call error', e);
                setPhase('Connection error: ' + (e && e.message), true);
              });
            });

            peer.on('disconnected', () => {
              log('Peer disconnected event');
              setPhase('Signaling disconnected. Attempting reconnect...', true);
            });

            peer.on('close', () => {
              log('Peer closed');
              setPhase('Peer closed', true);
            });
          }

          tryCreate();
        });
      }

      muteBtn.addEventListener('click', () => {
        if (!localStream) return;
        micEnabled = !micEnabled;
        localStream.getAudioTracks().forEach(t => t.enabled = micEnabled);
        muteBtn.textContent = micEnabled ? 'Mute Mic' : 'Unmute Mic';
        log('Mic toggled. Now enabled=', micEnabled);
      });

      endBtn.addEventListener('click', () => {
        log('End session clicked by host');
        cleanupAndEnd('Host ended session');
      });

      function cleanupAndEnd(reason){
        setPhase('Ending session: ' + reason, true);
        try {
          if (viewerCall) viewerCall.close();
          if (peer) peer.destroy();
          if (localStream) {
            localStream.getTracks().forEach(t => t.stop());
            localStream = null;
          }
        } catch(e){ log('Error during cleanup', e); }
        // show a message and show start button to allow restart
        startBtn.classList.remove('hidden');
        hostPreview.classList.add('hidden');
        hostControls.classList.add('hidden');
        running = false;
      }

      // expose for console convenience
      window._hostInternal = { ROOM_ID, ICE_SERVERS, log };
      startBtn.addEventListener('click', startSession);
      // initial accessible message
      phaseEl.textContent = 'Ready. Press Start Session to begin.';
      phaseEl.classList.remove('hidden');
      log('Host page ready');
    })();
  </script>
</body>
</html>