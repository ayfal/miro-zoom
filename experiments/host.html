<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Host</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{--bg:#0b0b0b;--fg:#f8f8f2;--accent:#ffcc00;}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;}
    #container{display:flex;flex-direction:column;height:100%;gap:10px;padding:12px;}
    .center{display:flex;align-items:center;justify-content:center;}
    #startBtn{font-size:20px;padding:14px 24px;border-radius:12px;border:4px solid var(--accent);background:var(--fg);color:var(--bg);cursor:pointer}
    #status{font-size:16px;padding:12px;border-radius:8px;background:#111;min-height:56px;white-space:pre-wrap;overflow:auto;}
    #previewFrame{flex:1;background:#000;border:4px solid #222;display:flex;align-items:center;justify-content:center;position:relative;}
    video#preview{max-width:100%;max-height:100%;border:2px solid #333;box-shadow:0 0 12px rgba(0,0,0,0.5);}
    #controls{display:flex;gap:8px;justify-content:center;padding:8px;}
    button.action{font-size:16px;padding:8px 12px;border-radius:8px;border:2px solid var(--accent);background:var(--bg);color:var(--fg);cursor:pointer}
    button.danger{border-color:#ff4444;color:#ffdddd}
    #smallNote{font-size:12px;color:#999;padding:4px 0;}
    @media (prefers-contrast: more){#startBtn{border-color:#fff}}
  </style>
</head>
<body>
  <div id="container">
    <div class="center">
      <button id="startBtn" aria-label="Start session as host">Start Session (Host)</button>
    </div>

    <div id="status" aria-live="polite">Ready.</div>

    <div id="previewFrame" aria-hidden="false">
      <div id="previewWrapper" class="center">
        <video id="preview" autoplay muted playsinline></video>
      </div>
    </div>

    <div id="controls" aria-hidden="true">
      <button id="muteBtn" class="action">Mute</button>
      <button id="endBtn" class="action danger">End Session</button>
    </div>

    <div id="smallNote">Signaling via PeerJS — host id: "unique-studyroom-for-host-and-visually-impaired"</div>
  </div>

  <script>
    // debug logs accessible via copy(window.getDebugLogs())
    (function(){
      const HOST_ID = "unique-studyroom-for-host-and-visually-impaired";
      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelay", credential: "openrelay" }
      ];
      const RETRY_DELAY_MS = 3000;

      let peer = null;
      let hostStream = null;
      let currentCall = null;
      let debugLogs = [];
      function dbg(...args){
        const t = new Date().toISOString();
        const msg = `[${t}] ${args.map(a=> (typeof a==='object'?JSON.stringify(a):a)).join(' ')}`;
        debugLogs.push(msg);
        console.log(msg);
        updateStatus(msg);
      }
      window.getDebugLogs = () => debugLogs.join('\n');

      const startBtn = document.getElementById('startBtn');
      const statusEl = document.getElementById('status');
      const preview = document.getElementById('preview');
      const controls = document.getElementById('controls');
      const muteBtn = document.getElementById('muteBtn');
      const endBtn = document.getElementById('endBtn');

      function updateStatus(txt){
        statusEl.textContent = txt;
      }

      async function getHostMedia(){
        updateStatus('Requesting screen capture & microphone permission...');
        dbg('requesting media: getDisplayMedia & getUserMedia (mic)');
        try {
          const screen = await navigator.mediaDevices.getDisplayMedia({video:true, audio:false});
          const mic = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
          const out = new MediaStream([
            ...screen.getVideoTracks(),
            ...mic.getAudioTracks()
          ]);
          dbg('media acquired', {videoTracks: screen.getVideoTracks().length, audioTracks: mic.getAudioTracks().length});
          return out;
        } catch (err){
          dbg('media permission denied or error', err && err.message);
          throw err;
        }
      }

      function attachPreview(stream){
        preview.srcObject = stream;
      }

      function initPeerWithRetry(){
        dbg('attempting to create Peer with fixed id', HOST_ID);
        updateStatus('Creating Peer with id "'+HOST_ID+'" ... (retrying if taken)');
        tryCreatePeer().catch(e=> {
          dbg('fatal peer creation error', e && e.message);
          updateStatus('Error creating peer: '+(e && e.message));
        });
      }

      function makePeer(){
        const p = new Peer(HOST_ID, {
          debug: 2,
          config: { iceServers: ICE_SERVERS }
        });
        return p;
      }

      async function tryCreatePeer(){
        let attempt = 0;
        while (true){
          attempt++;
          dbg('peer create attempt #' + attempt);
          updateStatus('Peer creation attempt #' + attempt + ' ...');
          try {
            peer = makePeer();
            let openResolved = false;
            await new Promise((resolve, reject) => {
              const onOpen = (id) => {
                openResolved = true;
                dbg('peer open', id);
                peer.off('error', onError);
                resolve();
              };
              const onError = (err) => {
                dbg('peer error event', err && err.type, err && err.message);
                peer.off('open', onOpen);
                reject(err);
              };
              // events
              peer.once('open', onOpen);
              peer.once('error', onError);
              // handle incoming calls
              peer.on('call', async (call) => {
                dbg('incoming call from', call.peer);
                updateStatus('Incoming connection from viewer: ' + call.peer + '\nAnswering with host screen+mic...');
                currentCall = call;
                try {
                  // make sure we have media; try to reacquire if not present
                  if (!hostStream) {
                    dbg('no hostStream available, attempting to reacquire media');
                    hostStream = await getHostMedia();
                    attachPreview(hostStream);
                  }

                  // debug hostStream tracks
                  dbg('hostStream tracks before answer', {
                    videoTracks: hostStream.getVideoTracks().length,
                    audioTracks: hostStream.getAudioTracks().length
                  });
                  hostStream.getVideoTracks().forEach((t,i)=> dbg(`host video[${i}]`, {id:t.id, kind:t.kind, enabled:t.enabled, readyState:t.readyState, label:t.label}));
                  hostStream.getAudioTracks().forEach((t,i)=> dbg(`host audio[${i}]`, {id:t.id, kind:t.kind, enabled:t.enabled, readyState:t.readyState, label:t.label}));

                  // ensure all tracks enabled
                  hostStream.getTracks().forEach(t => { t.enabled = true; });

                  // use a fresh MediaStream created from the current tracks to avoid track ownership/attachment edge-cases
                  const answerStream = new MediaStream(hostStream.getTracks());
                  dbg('answering call with cloned stream', {video: answerStream.getVideoTracks().length, audio: answerStream.getAudioTracks().length});
                  call.answer(answerStream);

                  dbg('answered call, now waiting for remote stream (viewer mic)');
                  call.on('stream', remoteStream => {
                    dbg('received remote stream from viewer', {tracks: remoteStream.getAudioTracks().length});
                    // play viewer audio locally
                    playRemoteAudio(remoteStream);
                    updateStatus('Connected: viewer audio receiving.\nSession established.');
                    // hide status/messages now that session is established
                    setTimeout(()=> updateStatus(''), 800);
                    // show controls
                    controls.setAttribute('aria-hidden','false');
                  });
                  call.on('close', ()=>{
                    dbg('call closed by remote');
                    updateStatus('Viewer disconnected.');
                    controls.setAttribute('aria-hidden','true');
                    currentCall = null;
                  });
                } catch (err){
                  dbg('error answering call', err && err.message);
                }
              });
            });
            // if resolved, break loop
            break;
          } catch (err){
            // Known id taken error usually has type 'unavailable-id' or message includes 'taken'
            const msg = err && (err.type || err.message || err);
            dbg('peer create failed', msg);
            // destroy peer instance if exists
            try { peer && peer.destroy(); } catch(e){}
            const isTaken = (err && (err.type === 'unavailable-id' || /taken/i.test(err.message || '')));
            if (isTaken){
              updateStatus('ID taken. Retrying in ' + (RETRY_DELAY_MS/1000) + 's ... (ID "'+HOST_ID+'")');
              dbg('id taken, will retry after delay');
              await new Promise(r => setTimeout(r, RETRY_DELAY_MS));
              continue;
            } else {
              throw err;
            }
          }
        }
        dbg('peer creation succeeded, now waiting for incoming viewer connections');
        updateStatus('Peer ready. Waiting for viewer to connect to id "'+HOST_ID+'"...');
      }

      function playRemoteAudio(stream){
        const audio = document.createElement('audio');
        audio.autoplay = true;
        audio.srcObject = stream;
        audio.play().catch(e => dbg('audio play error', e && e.message));
      }

      startBtn.addEventListener('click', async function(){
        startBtn.disabled = true;
        try {
          hostStream = await getHostMedia();
          attachPreview(hostStream);
          dbg('preview attached');
          // show short message
          updateStatus('Media ready. Creating Peer and listening for viewer...');
          initPeerWithRetry();
        } catch (err){
          updateStatus('Could not get required media: ' + (err && err.message));
          startBtn.disabled = false;
        }
      });

      muteBtn.addEventListener('click', ()=>{
        if (!hostStream) return;
        const audioTracks = hostStream.getAudioTracks();
        if (!audioTracks.length) return;
        const enabled = audioTracks[0].enabled;
        audioTracks.forEach(t => t.enabled = !enabled);
        muteBtn.textContent = enabled ? 'Unmute' : 'Mute';
        dbg('host mic ' + (enabled ? 'muted' : 'unmuted'));
      });

      endBtn.addEventListener('click', ()=>{
        dbg('end session requested by host');
        updateStatus('Ending session...');
        // close call
        try { currentCall && currentCall.close(); } catch(e){}
        try { peer && peer.destroy(); dbg('peer destroyed'); } catch(e){}
        try { hostStream && hostStream.getTracks().forEach(t=>t.stop()); dbg('host tracks stopped'); } catch(e){}
        controls.setAttribute('aria-hidden','true');
        preview.srcObject = null;
        startBtn.disabled = false;
        updateStatus('Session ended. Ready.');
      });

      // Clean up on unload
      window.addEventListener('beforeunload', ()=>{
        try { peer && peer.destroy(); } catch(e){}
        try { hostStream && hostStream.getTracks().forEach(t=>t.stop()); } catch(e){}
      });

      // initial state
      updateStatus('Ready. Press Start Session to begin.\nHost will share screen and mic. Viewer will connect using fixed id.');
      dbg('host page loaded');
    })();
  </script>
</body>
</html>