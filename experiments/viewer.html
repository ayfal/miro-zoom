<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing â€” Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{--bg:#000;--fg:#fff;--accent:#00ff66}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;}
    .center{display:flex;align-items:center;justify-content:center;}
    #bigBtn{
      position:fixed;inset:0;margin:auto;width:88vw;max-width:680px;height:200px;border-radius:20px;
      background:var(--fg);color:var(--bg);font-size:36px;font-weight:700;border:6px solid var(--accent);
      display:flex;align-items:center;justify-content:center;text-align:center;z-index:1000;cursor:pointer;
      box-shadow:0 6px 24px rgba(0,0,0,0.6);
    }
    #status{position:fixed;top:8px;left:8px;right:8px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.6);font-size:18px;z-index:1001;white-space:pre-wrap;}
    video#remote{position:fixed;inset:0;width:100%;height:100%;object-fit:contain;background:#000;touch-action:none;}
    /* viewer should have no visible controls; zoom/pan handled by gestures */
  </style>
</head>
<body>
  <div id="status" aria-live="polite">Ready.</div>
  <div id="bigBtn" role="button" aria-label="Connect as viewer">Connect to Studyroom</div>

  <video id="remote" autoplay playsinline></video>

  <script>
    (function(){
      const HOST_ID = "unique-studyroom-for-host-and-visually-impaired";
      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelay", credential: "openrelay" }
      ];

      let debugLogs = [];
      function dbg(...args){
        const t = new Date().toISOString();
        const msg = `[${t}] ${args.map(a=> (typeof a==='object'?JSON.stringify(a):a)).join(' ')}`;
        debugLogs.push(msg);
        console.log(msg);
        updateStatus(msg);
      }
      window.getDebugLogs = () => debugLogs.join('\n');

      const bigBtn = document.getElementById('bigBtn');
      const statusEl = document.getElementById('status');
      const remote = document.getElementById('remote');
      let peer = null;
      let localMic = null;
      let call = null;

      function updateStatus(txt){ statusEl.textContent = txt; }

      async function getMic(){
        dbg('requesting microphone permission');
        try {
          const mic = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
          dbg('microphone granted', {tracks: mic.getAudioTracks().length});
          return mic;
        } catch (err){
          dbg('microphone permission denied', err && err.message);
          throw err;
        }
      }

      function setupPeerAndCall(localStream){
        dbg('creating anonymous Peer and calling host', HOST_ID);
        peer = new Peer(null, { debug:2, config: { iceServers: ICE_SERVERS }});
        peer.on('open', id => {
          dbg('viewer peer open', id);
          updateStatus('Connecting to host "'+HOST_ID+'" ...');
          call = peer.call(HOST_ID, localStream);
          call.on('stream', remoteStream => {
            dbg('received host stream (screen+audio)', {
              videoTracks: remoteStream.getVideoTracks().length,
              audioTracks: remoteStream.getAudioTracks().length
            });

            // debug details for each track
            remoteStream.getVideoTracks().forEach((t,i)=> dbg(`video track[${i}]`, {id:t.id, kind:t.kind, enabled:t.enabled, readyState:t.readyState, label:t.label}));
            remoteStream.getAudioTracks().forEach((t,i)=> dbg(`audio track[${i}]`, {id:t.id, kind:t.kind, enabled:t.enabled, readyState:t.readyState, label:t.label}));

            // attach stream to video element and attempt to play (user already interacted)
            remote.srcObject = remoteStream;
            remote.style.display = 'block';
            remote.muted = false;
            remote.play().then(()=> {
              dbg('remote video.play() succeeded');
              // once remote stream arrives, hide status and big button
              bigBtn.style.display = 'none';
              setTimeout(()=> updateStatus(''), 600);
            }).catch(err=>{
              dbg('remote video.play() failed', err && err.message);
              // still hide the big button because stream arrived; show explanatory message
              bigBtn.style.display = 'none';
              if (remoteStream.getVideoTracks().length === 0) {
                updateStatus('Connected: audio received but no video tracks were sent by host.');
              } else {
                updateStatus('Connected, but playback failed: ' + (err && err.message));
              }
            });
          });
          call.on('close', ()=> {
            dbg('call closed by host or network');
            updateStatus('Connection closed.');
          });
          call.on('error', (e)=> {
            dbg('call error', e && e.message);
            updateStatus('Call error: '+(e && e.message));
          });
        });
        peer.on('error', e => {
          dbg('peer error', e && e.message);
          updateStatus('Peer error: '+(e && e.message));
        });
      }

      // Simple pinch-zoom & pan for touchscreens (no UI controls)
      (function addTouchTransform(){
        let scale = 1, lastScale = 1;
        let pos = {x:0,y:0}, lastPos = {x:0,y:0};
        let pointers = new Map();
        function applyTransform(){
          remote.style.transform = `translate(${pos.x}px, ${pos.y}px) scale(${scale})`;
        }
        function onPointerDown(e){
          pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
          remote.setPointerCapture && remote.setPointerCapture(e.pointerId);
          if (pointers.size === 1){
            lastPos = {x: e.clientX - pos.x, y: e.clientY - pos.y};
          }
        }
        function onPointerMove(e){
          if (!pointers.has(e.pointerId)) return;
          pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
          if (pointers.size === 1){
            const p = Array.from(pointers.values())[0];
            pos.x = e.clientX - lastPos.x;
            pos.y = e.clientY - lastPos.y;
          } else if (pointers.size >= 2){
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            const dx = b.x - a.x, dy = b.y - a.y;
            const dist = Math.hypot(dx,dy);
            if (!lastScale) lastScale = scale;
            if (!remote._baseDist) remote._baseDist = dist;
            const ratio = dist / remote._baseDist;
            scale = Math.max(1, Math.min(4, lastScale * ratio));
          }
          applyTransform();
        }
        function onPointerUp(e){
          pointers.delete(e.pointerId);
          if (pointers.size < 2) {
            lastScale = scale;
            remote._baseDist = null;
          }
        }
        remote.style.transition = 'transform 0.02s';
        remote.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('pointercancel', onPointerUp);
      })();

      bigBtn.addEventListener('click', async ()=>{
        bigBtn.disabled = true;
        updateStatus('Requesting microphone... (viewer will share mic only)');
        dbg('viewer start button clicked');
        try {
          const micStream = await getMic();
          localMic = micStream;
          updateStatus('Microphone granted. Creating connection to host...');
          setupPeerAndCall(localMic);
        } catch (err){
          updateStatus('Microphone permission required. ' + (err && err.message));
          bigBtn.disabled = false;
        }
      });

      // cleanup on unload
      window.addEventListener('beforeunload', ()=>{
        try { call && call.close(); } catch(e){}
        try { peer && peer.destroy(); } catch(e){}
        try { localMic && localMic.getTracks().forEach(t=>t.stop()); } catch(e){}
      });

      dbg('viewer page loaded. Ready.');
      updateStatus('Ready. Press the big CONNECT button (center) to begin.');
    })();
  </script>
</body>
</html>