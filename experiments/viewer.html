<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing â€” Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{--bg:#000;--fg:#fff;--accent:#00ff66;--zoom:1;}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;}
    .center{display:flex;align-items:center;justify-content:center;}
    #bigBtn{
      position:fixed;inset:0;margin:auto;width:88vw;max-width:680px;height:200px;border-radius:20px;
      background:var(--fg);color:var(--bg);font-size:36px;font-weight:700;border:6px solid var(--accent);
      display:flex;align-items:center;justify-content:center;text-align:center;z-index:1000;cursor:pointer;
      box-shadow:0 6px 24px rgba(0,0,0,0.6);
    }
    #status{position:fixed;top:8px;left:8px;right:8px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.6);font-size:18px;z-index:1001;white-space:pre-wrap;}
    /* transform-based zoom & pan */
    video#remote{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      object-fit:contain;
      background:#000;
      touch-action:none;
      transform-origin:center center;
      transform: translate(var(--pan-x, 0px), var(--pan-y, 0px)) scale(var(--zoom));
      transition: transform 0.02s linear;
      will-change: transform;
      cursor: grab;
    }
  </style>
</head>
<body>
  <div id="status" aria-live="polite">Ready.</div>
  <div id="bigBtn" role="button" aria-label="Connect as viewer">Connect to Studyroom</div>

  <video id="remote" autoplay playsinline></video>

  <script>
    (function(){
      const HOST_ID = "unique-studyroom-for-host-and-visually-impaired";
      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelay", credential: "openrelay" }
      ];
     // zoom/pan state (works with ctrl+wheel, ctrl+keys, pinch and mouse drag)
     let zoom = 1;
     let panX = 0;
     let panY = 0;
     const ZOOM_MIN = 1;
     const ZOOM_MAX = 4;
     const ZOOM_STEP = 0.12;
     const remoteEl = document.getElementById('remote');
     function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
     function applyTransform(){
       document.documentElement.style.setProperty('--zoom', String(zoom));
       document.documentElement.style.setProperty('--pan-x', panX + 'px');
       document.documentElement.style.setProperty('--pan-y', panY + 'px');
     }
     function zoomTo(newZoom, focalX = window.innerWidth/2, focalY = window.innerHeight/2){
       newZoom = clamp(newZoom, ZOOM_MIN, ZOOM_MAX);
       // adjust pan so focal point remains stationary (approximate)
       const prevZoom = zoom;
       const rect = remoteEl.getBoundingClientRect();
       const cx = rect.left + rect.width/2;
       const cy = rect.top + rect.height/2;
       // focal relative to center of element
       const fx = focalX - cx;
       const fy = focalY - cy;
       // scale the offset and adjust pan to keep focal point stable
       panX = panX - fx * (newZoom/prevZoom - 1);
       panY = panY - fy * (newZoom/prevZoom - 1);
       zoom = newZoom;
       applyTransform();
     }

     // wheel zoom (Ctrl / Meta + wheel)
     window.addEventListener('wheel', (e) => {
       if (!(e.ctrlKey || e.metaKey)) return;
       e.preventDefault();
       const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
       zoomTo( clamp(zoom + delta, ZOOM_MIN, ZOOM_MAX), e.clientX, e.clientY );
     }, { passive: false });

     // keyboard shortcuts: Ctrl/Cmd + + / - / 0
     window.addEventListener('keydown', (e) => {
       if (!(e.ctrlKey || e.metaKey)) return;
       if (e.key === '+' || e.key === '=' ) { e.preventDefault(); zoomTo( clamp(zoom + ZOOM_STEP, ZOOM_MIN, ZOOM_MAX) ); }
       else if (e.key === '-') { e.preventDefault(); zoomTo( clamp(zoom - ZOOM_STEP, ZOOM_MIN, ZOOM_MAX) ); }
       else if (e.key === '0') { e.preventDefault(); zoomTo(1); panX = 0; panY = 0; applyTransform(); }
     });

     // mouse drag to pan when zoomed
     let isDragging = false;
     let lastPointer = {x:0,y:0};
     remoteEl.addEventListener('pointerdown', (e) => {
       // only start drag with primary button and when not using ctrl (to allow pinch)
       if (e.button !== 0) return;
       isDragging = true;
       remoteEl.setPointerCapture && remoteEl.setPointerCapture(e.pointerId);
       lastPointer.x = e.clientX; lastPointer.y = e.clientY;
       remoteEl.style.cursor = 'grabbing';
     });
     window.addEventListener('pointermove', (e) => {
       if (!isDragging) return;
       const dx = e.clientX - lastPointer.x;
       const dy = e.clientY - lastPointer.y;
       lastPointer.x = e.clientX; lastPointer.y = e.clientY;
       // allow panning even at zoom==1 (keeps consistent), but it's most useful when zoom>1
       panX += dx;
       panY += dy;
       applyTransform();
     });
     window.addEventListener('pointerup', (e) => {
       if (!isDragging) return;
       isDragging = false;
       remoteEl.releasePointerCapture && remoteEl.releasePointerCapture(e.pointerId);
       remoteEl.style.cursor = 'grab';
     });
     // pinch gesture: handle via gesture events when available (fallback handled by wheel events)
     let pinchStartDist = 0;
     window.addEventListener('gesturestart', (e) => { pinchStartDist = zoom; });
     window.addEventListener('gesturechange', (e) => { if (e.scale) zoomTo(clamp(pinchStartDist * e.scale, ZOOM_MIN, ZOOM_MAX)); });
     // initial transform apply
     applyTransform();

      let debugLogs = [];
      function dbg(...args){
        const t = new Date().toISOString();
        const msg = `[${t}] ${args.map(a=> (typeof a==='object'?JSON.stringify(a):a)).join(' ')}`;
        debugLogs.push(msg);
        console.log(msg);
        updateStatus(msg);
      }
      window.getDebugLogs = () => debugLogs.join('\n');

      const bigBtn = document.getElementById('bigBtn');
      const statusEl = document.getElementById('status');
      const remote = document.getElementById('remote');
      let peer = null;
      let localMic = null;
      let dc = null;
      let pc = null;

      function updateStatus(txt){ statusEl.textContent = txt; }

      async function getMic(){
        dbg('requesting microphone permission');
        try {
          const mic = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
          dbg('microphone granted', {tracks: mic.getAudioTracks().length});
          return mic;
        } catch (err){
          dbg('microphone permission denied', err && err.message);
          throw err;
        }
      }

      function setupPeerAndConnect(localStream){
        dbg('creating anonymous Peer and connecting to host', HOST_ID);
        peer = new Peer(null, { debug:2, config: { iceServers: ICE_SERVERS }});
        peer.on('open', id => {
          dbg('viewer peer open', id);
          updateStatus('Connecting to host "'+HOST_ID+'" ...');
          dc = peer.connect(HOST_ID, { reliable: true });
          dc.on('open', async () => {
            dbg('data connection open to host');
            await createAndSendOffer(localStream);
          });
          dc.on('data', async (msg) => {
            dbg('data from host', msg && msg.type);
            if (!msg || !msg.type) return;
            if (msg.type === 'answer') {
              dbg('received SDP answer');
              try {
                // msg.sdp is a plain object (type/sdp) -> setRemoteDescription accepts that
                await pc.setRemoteDescription(msg.sdp);
                dbg('remote description set (answer)');
              } catch (e){
                dbg('setRemoteDescription(answer) failed', e && e.message);
                updateStatus('Failed to set remote description: ' + (e && e.message));
              }
            } else if (msg.type === 'candidate') {
              try {
                // msg.candidate is a plain candidate object
                await pc.addIceCandidate(msg.candidate);
                dbg('added remote ICE candidate');
              } catch (e){
                dbg('addIceCandidate error', e && e.message);
              }
            } else if (msg.type === 'error') {
              dbg('remote error', msg.message);
              updateStatus('Remote error: '+ msg.message);
            }
          });
          dc.on('close', ()=> {
            dbg('data connection closed by host');
            cleanup();
            updateStatus('Signaling connection closed.');
          });
          dc.on('error', (e)=> {
            dbg('data connection error', e && (e.message || e));
            updateStatus('Signaling error: ' + (e && e.message));
          });
        });

        peer.on('error', e => {
          dbg('peer error', e && e.message);
          updateStatus('Peer error: '+(e && e.message));
          bigBtn.disabled = false;
        });
      }

      async function createAndSendOffer(localStream){
        dbg('creating RTCPeerConnection and adding local tracks');
        pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

        // Ensure we signal that we want to receive video from host
        dbg('adding recvonly video transceiver to request remote screen');
        pc.addTransceiver('video', { direction: 'recvonly' });

        // add mic track(s) for sending back to host
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        dbg('local tracks added', {audio: localStream.getAudioTracks().length});

        pc.onicecandidate = (ev) => {
          if (ev.candidate && dc && dc.open) {
            dbg('sending ICE candidate to host');
            dc.send({ type:'candidate', candidate: ev.candidate.toJSON() });
          }
        };

        pc.ontrack = (ev) => {
          dbg('ontrack: remote stream arrived', {
            audioTracks: ev.streams[0] && ev.streams[0].getAudioTracks().length,
            videoTracks: ev.streams[0] && ev.streams[0].getVideoTracks().length
          });
          remote.srcObject = ev.streams[0];
          remote.muted = false;
          remote.play().then(()=> {
            dbg('remote video.play() succeeded');
            bigBtn.style.display = 'none';
            setTimeout(()=> updateStatus(''), 600);
            document.body.classList.add('session-started');
          }).catch(err=> {
            dbg('remote play() failed', err && err.message);
            bigBtn.style.display = 'none';
            if ((ev.streams[0].getVideoTracks().length || 0) === 0) {
              updateStatus('Connected: audio received but no video was sent by host.');
            } else {
              updateStatus('Connected but playback failed: ' + (err && err.message));
            }
          });
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        dbg('sending SDP offer to host');
        dc.send({ type:'offer', sdp: pc.localDescription.toJSON() });
      }

      function cleanup(){
        try { pc && pc.close(); } catch(e){}
        pc = null;
        try { dc && dc.close(); } catch(e){}
        dc = null;
        try { peer && peer.destroy(); } catch(e){}
        peer = null;
      }

      bigBtn.addEventListener('click', async ()=>{
        bigBtn.disabled = true;
        updateStatus('Requesting microphone... (viewer will share mic only)');
        dbg('viewer start button clicked');
        try {
          const micStream = await getMic();
          localMic = micStream;
          updateStatus('Microphone granted. Creating connection to host...');
          setupPeerAndConnect(localMic);
        } catch (err){
          updateStatus('Microphone permission required. ' + (err && err.message));
          bigBtn.disabled = false;
        }
      });

      window.addEventListener('beforeunload', ()=>{
        try { dc && dc.send && dc.send({type:'hangup'}); } catch(e){}
        cleanup();
        try { localMic && localMic.getTracks().forEach(t=>t.stop()); } catch(e){}
      });

      dbg('viewer page loaded. Ready.');
      updateStatus('Ready. Press the big CONNECT button (center) to begin.');
    })();
  </script>
</body>
</html>