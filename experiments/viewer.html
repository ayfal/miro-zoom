<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing â€” Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{--bg:#000;--fg:#fff;--accent:#00ff66}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;}
    .center{display:flex;align-items:center;justify-content:center;}
    #bigBtn{
      position:fixed;inset:0;margin:auto;width:88vw;max-width:680px;height:200px;border-radius:20px;
      background:var(--fg);color:var(--bg);font-size:36px;font-weight:700;border:6px solid var(--accent);
      display:flex;align-items:center;justify-content:center;text-align:center;z-index:1000;cursor:pointer;
      box-shadow:0 6px 24px rgba(0,0,0,0.6);
    }
    #status{position:fixed;top:8px;left:8px;right:8px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.6);font-size:18px;z-index:1001;white-space:pre-wrap;}
    video#remote{position:fixed;inset:0;width:100%;height:100%;object-fit:contain;background:#000;touch-action:none;}
  </style>
</head>
<body>
  <div id="status" aria-live="polite">Ready.</div>
  <div id="bigBtn" role="button" aria-label="Connect as viewer">Connect to Studyroom</div>

  <video id="remote" autoplay playsinline></video>

  <script>
    (function(){
      const HOST_ID = "unique-studyroom-for-host-and-visually-impaired";
      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelay", credential: "openrelay" }
      ];

      let debugLogs = [];
      function dbg(...args){
        const t = new Date().toISOString();
        const msg = `[${t}] ${args.map(a=> (typeof a==='object'?JSON.stringify(a):a)).join(' ')}`;
        debugLogs.push(msg);
        console.log(msg);
        updateStatus(msg);
      }
      window.getDebugLogs = () => debugLogs.join('\n');

      const bigBtn = document.getElementById('bigBtn');
      const statusEl = document.getElementById('status');
      const remote = document.getElementById('remote');
      let peer = null;
      let localMic = null;
      let dc = null;
      let pc = null;

      function updateStatus(txt){ statusEl.textContent = txt; }

      async function getMic(){
        dbg('requesting microphone permission');
        try {
          const mic = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
          dbg('microphone granted', {tracks: mic.getAudioTracks().length});
          return mic;
        } catch (err){
          dbg('microphone permission denied', err && err.message);
          throw err;
        }
      }

      function setupPeerAndConnect(localStream){
        dbg('creating anonymous Peer and connecting to host', HOST_ID);
        peer = new Peer(null, { debug:2, config: { iceServers: ICE_SERVERS }});
        peer.on('open', id => {
          dbg('viewer peer open', id);
          updateStatus('Connecting to host "'+HOST_ID+'" ...');
          dc = peer.connect(HOST_ID, { reliable: true });
          dc.on('open', async () => {
            dbg('data connection open to host');
            await createAndSendOffer(localStream);
          });
          dc.on('data', async (msg) => {
            dbg('data from host', msg && msg.type);
            if (!msg || !msg.type) return;
            if (msg.type === 'answer') {
              dbg('received SDP answer');
              try {
                // msg.sdp is a plain object (type/sdp) -> setRemoteDescription accepts that
                await pc.setRemoteDescription(msg.sdp);
                dbg('remote description set (answer)');
              } catch (e){
                dbg('setRemoteDescription(answer) failed', e && e.message);
                updateStatus('Failed to set remote description: ' + (e && e.message));
              }
            } else if (msg.type === 'candidate') {
              try {
                // msg.candidate is a plain candidate object
                await pc.addIceCandidate(msg.candidate);
                dbg('added remote ICE candidate');
              } catch (e){
                dbg('addIceCandidate error', e && e.message);
              }
            } else if (msg.type === 'error') {
              dbg('remote error', msg.message);
              updateStatus('Remote error: '+ msg.message);
            }
          });
          dc.on('close', ()=> {
            dbg('data connection closed by host');
            cleanup();
            updateStatus('Signaling connection closed.');
          });
          dc.on('error', (e)=> {
            dbg('data connection error', e && (e.message || e));
            updateStatus('Signaling error: ' + (e && e.message));
          });
        });

        peer.on('error', e => {
          dbg('peer error', e && e.message);
          updateStatus('Peer error: '+(e && e.message));
          bigBtn.disabled = false;
        });
      }

      async function createAndSendOffer(localStream){
        dbg('creating RTCPeerConnection and adding local tracks');
        pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

        // add mic track(s)
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        dbg('local tracks added', {audio: localStream.getAudioTracks().length});

        pc.onicecandidate = (ev) => {
          if (ev.candidate && dc && dc.open) {
            dbg('sending ICE candidate to host');
            // send a plain-serializable candidate object
            dc.send({ type:'candidate', candidate: ev.candidate.toJSON() });
          }
        };

        pc.ontrack = (ev) => {
          dbg('ontrack: remote stream arrived', {
            audioTracks: ev.streams[0] && ev.streams[0].getAudioTracks().length,
            videoTracks: ev.streams[0] && ev.streams[0].getVideoTracks().length
          });
          remote.srcObject = ev.streams[0];
          remote.muted = false;
          remote.play().then(()=> {
            dbg('remote video.play() succeeded');
            bigBtn.style.display = 'none';
            setTimeout(()=> updateStatus(''), 600);
            document.body.classList.add('session-started');
          }).catch(err=> {
            dbg('remote play() failed', err && err.message);
            bigBtn.style.display = 'none';
            if ((ev.streams[0].getVideoTracks().length || 0) === 0) {
              updateStatus('Connected: audio received but no video was sent by host.');
            } else {
              updateStatus('Connected but playback failed: ' + (err && err.message));
            }
          });
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        dbg('sending SDP offer to host');
        // send serializable SDP (plain object)
        dc.send({ type:'offer', sdp: pc.localDescription.toJSON() });
      }

      function cleanup(){
        try { pc && pc.close(); } catch(e){}
        pc = null;
        try { dc && dc.close(); } catch(e){}
        dc = null;
        try { peer && peer.destroy(); } catch(e){}
        peer = null;
      }

      bigBtn.addEventListener('click', async ()=>{
        bigBtn.disabled = true;
        updateStatus('Requesting microphone... (viewer will share mic only)');
        dbg('viewer start button clicked');
        try {
          const micStream = await getMic();
          localMic = micStream;
          updateStatus('Microphone granted. Creating connection to host...');
          setupPeerAndConnect(localMic);
        } catch (err){
          updateStatus('Microphone permission required. ' + (err && err.message));
          bigBtn.disabled = false;
        }
      });

      window.addEventListener('beforeunload', ()=>{
        try { dc && dc.send && dc.send({type:'hangup'}); } catch(e){}
        cleanup();
        try { localMic && localMic.getTracks().forEach(t=>t.stop()); } catch(e){}
      });

      dbg('viewer page loaded. Ready.');
      updateStatus('Ready. Press the big CONNECT button (center) to begin.');
    })();
  </script>
</body>
</html>