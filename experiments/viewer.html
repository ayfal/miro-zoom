<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Viewer â€” Study Room</title>
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; touch-action:none; overflow:hidden; }
    #startBtn {
      position:fixed; left:50%; transform:translateX(-50%); bottom:6vh;
      font-size:44px; padding:28px 40px; border-radius:14px; background:#ff0; color:#000; border:4px solid #000;
      z-index:30; min-width:360px; text-align:center;
    }
    #phase {
      position:fixed; left:50%; transform:translateX(-50%); top:6vh; font-size:28px; background:#111; padding:12px 18px; border-radius:10px; z-index:30;
      max-width:95%; text-align:center;
    }
    #remoteVideo {
      width:100%; height:100%; object-fit:contain; background:#000; touch-action:none;
      transform-origin: center center;
    }
  </style>
</head>
<body>
  <button id="startBtn" aria-label="Connect">Connect</button>
  <div id="phase" class="" role="status" aria-live="assertive">Ready. Press Connect.</div>
  <video id="remoteVideo" autoplay playsinline></video>

  <script>
    // Viewer logic
    (function(){
      const ROOM_ID = 'unique-studyroom-for-host-and-visually-impaired';
      const ICE_SERVERS = [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:openrelay.metered.ca:80", username: "openrelayproject", credential: "openrelayproject" },
        { urls: "turn:openrelay.metered.ca:443", username: "openrelayproject", credential: "openrelayproject" },
        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" }
      ];

      const viewerLogs = [];
      function log(...args){ const t=new Date().toISOString()+' VIEWER:'; viewerLogs.push(t+' '+args.map(String).join(' ')); console.log(t, ...args); }
      window.getViewerDebugLogs = () => viewerLogs.join('\n');

      const startBtn = document.getElementById('startBtn');
      const phaseEl = document.getElementById('phase');
      const remoteVideo = document.getElementById('remoteVideo');

      let peer = null;
      let localStream = null;
      let currentCall = null;

      function setPhase(text, verbose=false){
        phaseEl.textContent = text;
        if (verbose) log('PHASE:', text);
      }

      async function startViewer(){
        startBtn.classList.add('hidden');
        setPhase('Requesting microphone permission...');
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
          log('Acquired local microphone tracks:', localStream.getAudioTracks().map(t=>t.id+'['+t.kind+']'));
          setPhase('Microphone obtained. Initializing Peer and calling host...', true);
          peer = new Peer({ config: { iceServers: ICE_SERVERS } });
          peer.on('open', id => {
            log('Viewer peer open', id);
            setPhase('Calling host: ' + ROOM_ID, true);
            currentCall = peer.call(ROOM_ID, localStream);
            attachCallHandlers(currentCall);
          });
          peer.on('error', err => {
            log('Peer error', err);
            setPhase('Signaling error: ' + (err && err.message), true);
            // show connect button again so user can retry
            startBtn.classList.remove('hidden');
          });
        } catch(err){
          log('Media error', err);
          setPhase('Microphone permission denied or error: ' + (err && err.message), true);
          startBtn.classList.remove('hidden');
        }
      }

      function attachCallHandlers(call){
        if (!call) return;
        call.on('stream', remoteStream => {
          log('Received remote stream (screen) tracks:', remoteStream.getTracks().map(t => t.kind+'['+t.id+']'));
          // attach to full-window video
          remoteVideo.srcObject = remoteStream;

          // Attempt to play and surface errors
          remoteVideo.play().then(() => {
            log('remoteVideo.play() succeeded');
          }).catch(e => {
            log('remoteVideo.play() failed', e);
            // If autoplay blocked, show message and keep connect button so user can retry after interacting.
            setPhase('Unable to autoplay remote video due to browser policy. Tap the screen to start video.', true);
            startBtn.classList.remove('hidden');
          });

          // If no video tracks were present, inform user via phase (debug)
          const videoTracks = remoteStream.getVideoTracks();
          if (!videoTracks || videoTracks.length === 0){
            log('No video tracks in remoteStream; viewer will only hear audio.');
            setPhase('No screen video received from host. Audio is playing.', true);
          } else {
            // hide phase and start button once we have remote content
            phaseEl.classList.add('hidden');
            startBtn.classList.add('hidden');
          }
        });
        call.on('close', () => {
          log('Call closed by host');
          setPhase('Host disconnected', true);
          // show connect button again
          startBtn.classList.remove('hidden');
        });
        call.on('error', e => {
          log('Call error', e);
          setPhase('Connection error: ' + (e && e.message), true);
          startBtn.classList.remove('hidden');
        });
      }

      // Touch/pinch pan/zoom for remoteVideo (no visible UI)
      (function addTouchPanZoom(){
        let scale = 1, lastScale = 1;
        let pos = { x:0, y:0 }, lastPos = { x:0, y:0 };
        let pointers = [];
        function setTransform(){ remoteVideo.style.transform = `translate(${pos.x}px, ${pos.y}px) scale(${scale})`; }
        function midpoint(p1,p2){ return {x:(p1.clientX+p2.clientX)/2, y:(p1.clientY+p2.clientY)/2}; }
        remoteVideo.addEventListener('pointerdown', e => {
          pointers.push(e);
          remoteVideo.setPointerCapture(e.pointerId);
        });
        remoteVideo.addEventListener('pointermove', e => {
          for(let i=0;i<pointers.length;i++) if(pointers[i].pointerId===e.pointerId) pointers[i]=e;
          if (pointers.length===1){
            const dx = e.movementX || (e.clientX - (lastPos.x || e.clientX));
            const dy = e.movementY || (e.clientY - (lastPos.y || e.clientY));
            pos.x += dx;
            pos.y += dy;
            lastPos.x = e.clientX;
            lastPos.y = e.clientY;
            setTransform();
          } else if (pointers.length>=2){
            const p1 = pointers[0], p2 = pointers[1];
            const d = Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
            if (!lastScale) lastScale = d;
            const factor = d / lastScale;
            scale *= factor;
            // clamp scale
            scale = Math.max(1, Math.min(4, scale));
            lastScale = d;
            setTransform();
          }
        });
        function endPointer(e){
          pointers = pointers.filter(p => p.pointerId !== e.pointerId);
          if (pointers.length===0){
            lastScale = 1;
            lastPos = {x:0,y:0};
          }
        }
        remoteVideo.addEventListener('pointerup', endPointer);
        remoteVideo.addEventListener('pointercancel', endPointer);
        remoteVideo.addEventListener('pointerout', endPointer);
        remoteVideo.addEventListener('pointerleave', endPointer);
        // double-tap to reset
        let lastTap=0;
        remoteVideo.addEventListener('click', e => {
          const now = Date.now();
          if (now - lastTap < 300){
            scale = 1; pos={x:0,y:0}; setTransform();
            // if autoplay was blocked earlier, the tap should allow play
            if (remoteVideo.paused && remoteVideo.srcObject) {
              remoteVideo.play().then(()=>log('remoteVideo.play() after tap succeeded')).catch(err=>log('play after tap failed', err));
            }
          }
          lastTap = now;
        });
      })();

      startBtn.addEventListener('click', startViewer);
      log('Viewer page ready');
    })();
  </script>
</body>
</html>