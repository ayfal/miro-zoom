<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{--bg:#000;--fg:#fff;--accent:#00ff66}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;}
    .center{display:flex;align-items:center;justify-content:center;}
    #bigBtn{
      position:fixed;inset:0;margin:auto;width:88vw;max-width:680px;height:200px;border-radius:20px;
      background:var(--fg);color:var(--bg);font-size:36px;font-weight:700;border:6px solid var(--accent);
      display:flex;align-items:center;justify-content:center;text-align:center;z-index:1000;cursor:pointer;
      box-shadow:0 6px 24px rgba(0,0,0,0.6);
    }
    /* progress bar replaces verbose status text */
    #progressContainer { position:fixed; top:8px; left:8px; right:8px; z-index:1001; padding:8px; }
    #progressBar { height:14px; background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; border:2px solid rgba(255,255,255,0.04); }
    #progressFill { width:0%; height:100%; background:var(--accent); transition: width 220ms linear; }
    #progressText { margin-top:6px; text-align:center; font-size:16px; color:#ffd; min-height:20px; }
    video#remote{position:fixed;inset:0;width:100%;height:100%;object-fit:contain;background:#000;touch-action:none;}
  </style>
</head>
<body>
  <div id="progressContainer" aria-live="polite" role="status" aria-atomic="true">
    <div id="progressBar"><div id="progressFill"></div></div>
    <div id="progressText">Ready.</div>
  </div>
   <div id="bigBtn" role="button" aria-label="Connect as viewer">Connect to Studyroom</div>

   <video id="remote" autoplay playsinline></video>

   <script>
     (function(){
       const HOST_ID = "unique-studyroom-for-host-and-visually-impaired";
       const ICE_SERVERS = [
         { urls: "stun:stun.l.google.com:19302" },
         { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelay", credential: "openrelay" }
       ];

       let debugLogs = [];
      function dbg(...args){
        const t = new Date().toISOString();
        const msg = `[${t}] ${args.map(a=> (typeof a==='object'?JSON.stringify(a):a)).join(' ')}`;
        debugLogs.push(msg);
        console.log(msg);
      }
       window.getDebugLogs = () => debugLogs.join('\n');

      const bigBtn = document.getElementById('bigBtn');
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
       const remote = document.getElementById('remote');
       let peer = null;
       let localMic = null;
       let dc = null;
       let pc = null;

      function setProgress(text, pct){
        progressText.textContent = text || '';
        progressFill.style.width = (typeof pct === 'number' ? pct : 0) + '%';
      }
      function hideProgress(){
        try { document.getElementById('progressContainer').style.display = 'none'; } catch(e){}
      }

       async function getMic(){
        setProgress('Requesting microphone…', 5);
        dbg('requesting microphone permission');
         try {
           const mic = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
          dbg('microphone granted', {tracks: mic.getAudioTracks().length});
          setProgress('Microphone granted', 20);
           return mic;
         } catch (err){
          dbg('microphone permission denied', err && err.message);
          setProgress('Microphone permission error', 0);
           throw err;
         }
       }

       function setupPeerAndConnect(localStream){
         dbg('creating anonymous Peer and connecting to host', HOST_ID);
         peer = new Peer(null, { debug:2, config: { iceServers: ICE_SERVERS }});
         peer.on('open', id => {
           dbg('viewer peer open', id);
          updateStatus('Connecting to host "'+HOST_ID+'" ...');
          setProgress('Connecting to host…', 40);
           dc = peer.connect(HOST_ID, { reliable: true });
           dc.on('open', async () => {
             dbg('data connection open to host');
            await createAndSendOffer(localStream);
            setProgress('Signaling connected', 50);
            await createAndSendOffer(localStream);
           });
           dc.on('data', async (msg) => {
             dbg('data from host', msg && msg.type);
             if (!msg || !msg.type) return;
             if (msg.type === 'answer') {
               dbg('received SDP answer');
               try {
                 // msg.sdp is a plain object (type/sdp) -> setRemoteDescription accepts that
                 await pc.setRemoteDescription(msg.sdp);
                dbg('remote description set (answer)');
                dbg('remote description set (answer)');
                setProgress('Connected (establishing media)…', 75);
               } catch (e){
                 dbg('setRemoteDescription(answer) failed', e && e.message);
                updateStatus('Failed to set remote description: ' + (e && e.message));
                setProgress('Failed to set remote description', 0);
               }
             } else if (msg.type === 'candidate') {
               try {
                 await pc.addIceCandidate(msg.candidate);
                 dbg('added remote ICE candidate');
               } catch (e){
                 dbg('addIceCandidate error', e && e.message);
               }
             } else if (msg.type === 'error') {
               dbg('remote error', msg.message);
              updateStatus('Remote error: '+ msg.message);
              setProgress('Remote error', 0);
             }
           });
           dc.on('close', ()=> {
             dbg('data connection closed by host');
             cleanup();
            updateStatus('Signaling connection closed.');
            setProgress('Signaling connection closed', 0);
           });
           dc.on('error', (e)=> {
             dbg('data connection error', e && (e.message || e));
            updateStatus('Signaling error: ' + (e && e.message));
            setProgress('Signaling error', 0);
             bigBtn.disabled = false;
           });
         });

         peer.on('error', e => {
           dbg('peer error', e && e.message);
          updateStatus('Peer error: '+(e && e.message));
          setProgress('Peer error', 0);
           bigBtn.disabled = false;
         });
       }

       async function createAndSendOffer(localStream){
         dbg('creating RTCPeerConnection and adding local tracks');
         pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

         // Ensure we signal that we want to receive video from host
         dbg('adding recvonly video transceiver to request remote screen');
         pc.addTransceiver('video', { direction: 'recvonly' });

         // add mic track(s) for sending back to host
         localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        dbg('local tracks added', {audio: localStream.getAudioTracks().length});
        dbg('local tracks added', {audio: localStream.getAudioTracks().length});
        setProgress('Creating offer', 60);

         pc.onicecandidate = (ev) => {
           if (ev.candidate && dc && dc.open) {
             dbg('sending ICE candidate to host');
             dc.send({ type:'candidate', candidate: ev.candidate.toJSON() });
           }
         };

         pc.ontrack = (ev) => {
           dbg('ontrack: remote stream arrived', {
             audioTracks: ev.streams[0] && ev.streams[0].getAudioTracks().length,
             videoTracks: ev.streams[0] && ev.streams[0].getVideoTracks().length
           });
           remote.srcObject = ev.streams[0];
           remote.muted = false;
           remote.play().then(()=> {
             dbg('remote video.play() succeeded');
             bigBtn.style.display = 'none';
             // hide progress UI now that media is playing
             hideProgress();
             document.body.classList.add('session-started');
           }).catch(err=> {
             dbg('remote play() failed', err && err.message);
             bigBtn.style.display = 'none';
             if ((ev.streams[0].getVideoTracks().length || 0) === 0) {
                setProgress('Connected: audio only', 100);
              } else {
                setProgress('Connected but playback failed', 0);
              }
           });
         };

         const offer = await pc.createOffer();
         await pc.setLocalDescription(offer);
        dbg('sending SDP offer to host');
        dc.send({ type:'offer', sdp: pc.localDescription.toJSON() });
        dbg('sending SDP offer to host');
        setProgress('Offer sent — waiting for answer', 70);
        dc.send({ type:'offer', sdp: pc.localDescription.toJSON() });
       }

      function cleanup(){
        try { pc && pc.close(); } catch(e){}
        pc = null;
        try { dc && dc.close(); } catch(e){}
        dc = null;
        try { peer && peer.destroy(); } catch(e){}
        peer = null;
      }

      bigBtn.addEventListener('click', async ()=>{
        bigBtn.disabled = true;
        setProgress('Requesting microphone... (viewer will share mic only)');
        dbg('viewer start button clicked');
        try {
          const micStream = await getMic();
          localMic = micStream;
          setProgress('Microphone granted. Creating connection to host...');
          setupPeerAndConnect(localMic);
        } catch (err){
          setProgress('Microphone permission required. ' + (err && err.message));
          bigBtn.disabled = false;
        }
      });

      window.addEventListener('beforeunload', ()=>{
        try { dc && dc.send && dc.send({type:'hangup'}); } catch(e){}
        cleanup();
        try { localMic && localMic.getTracks().forEach(t=>t.stop()); } catch(e){}
      });

      // Compatibility shim: some code still calls updateStatus().
      // Map it to setProgress (if available) so it updates the progress UI instead of throwing.
      function updateStatus(text){
        try {
          if (typeof setProgress === 'function') {
            // Use a neutral progress value when unspecified
            setProgress(text, 50);
          } else {
            // fallback: update progress text element directly if present
            const el = document.getElementById('progressText');
            if (el) el.textContent = text;
            else console.log('status:', text);
          }
        } catch(e){
          console.log('updateStatus error', e && e.message);
        }
      }

      dbg('viewer page loaded. Ready.');
      updateStatus('Ready. Press the big CONNECT button (center) to begin.');
      setProgress('Ready. Press the big CONNECT button', 0);
     })();
   </script>
 </body>
 </html>