<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PeerSharing — Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    :root{--bg:#000;--fg:#fff;--accent:#00ff66}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;}
    .center{display:flex;align-items:center;justify-content:center;}
    #bigBtn{
      position:fixed;inset:0;margin:auto;width:88vw;max-width:680px;height:200px;border-radius:20px;
      background:var(--fg);color:var(--bg);font-size:36px;font-weight:700;border:6px solid var(--accent);
      display:flex;align-items:center;justify-content:center;text-align:center;z-index:1000;cursor:pointer;
      box-shadow:0 6px 24px rgba(0,0,0,0.6);
    }
    /* progress bar replaces verbose status text */
    #progressContainer { position:fixed; top:8px; left:8px; right:8px; z-index:1001; padding:8px; }
    #progressBar { height:14px; background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; border:2px solid rgba(255,255,255,0.04); }
    #progressFill { width:0%; height:100%; background:var(--accent); transition: width 220ms linear; }
    #progressText { margin-top:6px; text-align:center; font-size:16px; color:#ffd; min-height:20px; }
    video#remote{position:fixed;inset:0;width:100%;height:100%;object-fit:contain;background:#000;touch-action:none;}
  </style>
</head>
<body>
  <div id="progressContainer" aria-live="polite" role="status" aria-atomic="true">
    <div id="progressBar"><div id="progressFill"></div></div>
    <div id="progressText">Ready.</div>
  </div>
   <div id="bigBtn" role="button" aria-label="Connect as viewer">Connect to Studyroom</div>

   <video id="remote" autoplay playsinline></video>

   <script>
     (function(){
       const HOST_ID = "unique-studyroom-for-host-and-visually-impaired";
       const ICE_SERVERS = [
         { urls: "stun:stun.l.google.com:19302" },
         { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelay", credential: "openrelay" }
       ];

       let debugLogs = [];
      function dbg(...args){
        const t = new Date().toISOString();
        const msg = `[${t}] ${args.map(a=> (typeof a==='object'?JSON.stringify(a):a)).join(' ')}`;
        debugLogs.push(msg);
        console.log(msg);
      }
       window.getDebugLogs = () => debugLogs.join('\n');

      const bigBtn = document.getElementById('bigBtn');
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
       const remote = document.getElementById('remote');
       let peer = null;
       let localMic = null;
       let dc = null;
       let pc = null;
       let offerSent = false;
       let pendingRemoteCandidates = [];

      function setProgress(text, pct){
        progressText.textContent = text || '';
        progressFill.style.width = (typeof pct === 'number' ? pct : 0) + '%';
      }
      function hideProgress(){
        try { document.getElementById('progressContainer').style.display = 'none'; } catch(e){}
      }

       async function getMic(){
        setProgress('Requesting microphone…', 5);
        dbg('requesting microphone permission');
         try {
           const mic = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
          dbg('microphone granted', {tracks: mic.getAudioTracks().length});
          setProgress('Microphone granted', 20);
           return mic;
         } catch (err){
          dbg('microphone permission denied', err && err.message);
          setProgress('Microphone permission error', 0);
           throw err;
         }
       }

       function setupPeerAndConnect(localStream){
         dbg('creating anonymous Peer and connecting to host', HOST_ID);
         peer = new Peer(null, { debug:2, config: { iceServers: ICE_SERVERS }});
         peer.on('open', id => {
           dbg('viewer peer open', id);
          updateStatus('Connecting to host "'+HOST_ID+'" ...');
          setProgress('Connecting to host…', 40);
           dc = peer.connect(HOST_ID, { reliable: true });
           dc.on('open', async () => {
             dbg('data connection open to host');
             setProgress('Signaling connected', 50);
             // ensure we only send one offer per connection
             if (!offerSent) {
               offerSent = true;
               await createAndSendOffer(localStream);
             } else {
               dbg('offer already sent, skipping duplicate');
             }
           });
           dc.on('data', async (msg) => {
             dbg('data from host', msg && msg.type);
             if (!msg || !msg.type) return;
             if (msg.type === 'answer') {
               dbg('received SDP answer');
               try {
                 // Only set remote description if PC exists and we are in the right state
                 if (pc && (pc.signalingState === 'have-local-offer' || pc.signalingState === 'have-remote-offer' || pc.signalingState === 'stable')) {
                   await pc.setRemoteDescription(msg.sdp);
                   dbg('remote description set (answer)');
                   // flush any queued remote ICE candidates
                   while (pendingRemoteCandidates.length) {
                     const c = pendingRemoteCandidates.shift();
                     try { await pc.addIceCandidate(c); dbg('flushed queued remote candidate'); } catch(e){ dbg('flush candidate failed', e && e.message); }
                   }
                 } else {
                   dbg('answer received but PC not in have-local-offer state; ignoring or queuing', pc && pc.signalingState);
                 }
               } catch (e){
                 dbg('setRemoteDescription(answer) failed', e && e.message);
                 setProgress('Failed to set remote description', 0);
               }
             } else if (msg.type === 'candidate') {
               // If pc not ready with remote description yet, queue candidates
               if (!pc || !pc.remoteDescription || !pc.remoteDescription.type) {
                 dbg('queuing remote candidate until remote description set');
                 pendingRemoteCandidates.push(msg.candidate);
               } else {
                 try {
                   await pc.addIceCandidate(msg.candidate);
                   dbg('added remote ICE candidate');
                 } catch (e){
                   dbg('addIceCandidate error', e && e.message);
                 }
               }
             } else if (msg.type === 'error') {
               dbg('remote error', msg.message);
               setProgress('Remote error', 0);
             }
           });
           dc.on('close', ()=> {
             dbg('data connection closed by host');
             cleanup();
            updateStatus('Signaling connection closed.');
            setProgress('Signaling connection closed', 0);
           });
           dc.on('error', (e)=> {
             dbg('data connection error', e && (e.message || e));
            updateStatus('Signaling error: ' + (e && e.message));
            setProgress('Signaling error', 0);
             bigBtn.disabled = false;
           });
         });

         peer.on('error', e => {
           dbg('peer error', e && e.message);
          updateStatus('Peer error: '+(e && e.message));
          setProgress('Peer error', 0);
           bigBtn.disabled = false;
         });
       }

       async function createAndSendOffer(localStream){
         dbg('creating RTCPeerConnection and adding local tracks');
         pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

         // Ensure we signal that we want to receive video from host
         dbg('adding recvonly video transceiver to request remote screen');
         pc.addTransceiver('video', { direction: 'recvonly' });

         // add mic track(s) for sending back to host
         localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        dbg('local tracks added', {audio: localStream.getAudioTracks().length});
        dbg('local tracks added', {audio: localStream.getAudioTracks().length});
        setProgress('Creating offer', 60);

         pc.onicecandidate = (ev) => {
           if (ev.candidate && dc && dc.open) {
             dbg('sending ICE candidate to host');
             dc.send({ type:'candidate', candidate: ev.candidate.toJSON() });
           }
         };

         pc.ontrack = (ev) => {
           dbg('ontrack: remote stream arrived', {
             audioTracks: ev.streams[0] && ev.streams[0].getAudioTracks().length,
             videoTracks: ev.streams[0] && ev.streams[0].getVideoTracks().length
           });
           remote.srcObject = ev.streams[0];
           remote.muted = false;
           remote.play().then(()=> {
             dbg('remote video.play() succeeded');
             bigBtn.style.display = 'none';
             // hide progress UI now that media is playing
             hideProgress();
             document.body.classList.add('session-started');
           }).catch(err=> {
             dbg('remote play() failed', err && err.message);
             bigBtn.style.display = 'none';
             if ((ev.streams[0].getVideoTracks().length || 0) === 0) {
                setProgress('Connected: audio only', 100);
              } else {
                setProgress('Connected but playback failed', 0);
              }
           });
         };

         const offer = await pc.createOffer();
         await pc.setLocalDescription(offer);
        dbg('sending SDP offer to host');
        dc.send({ type:'offer', sdp: pc.localDescription.toJSON() });
        dbg('sending SDP offer to host');
        setProgress('Offer sent — waiting for answer', 70);
        dc.send({ type:'offer', sdp: pc.localDescription.toJSON() });
       }

      function cleanup(){
        try { pc && pc.close(); } catch(e){}
        pc = null;
        try { dc && dc.close(); } catch(e){}
        dc = null;
        try { peer && peer.destroy(); } catch(e){}
        peer = null;
      }

      bigBtn.addEventListener('click', async ()=>{
        bigBtn.disabled = true;
        setProgress('Requesting microphone... (viewer will share mic only)');
        dbg('viewer start button clicked');
        try {
          const micStream = await getMic();
          localMic = micStream;
          setProgress('Microphone granted. Creating connection to host...');
          setupPeerAndConnect(localMic);
        } catch (err){
          setProgress('Microphone permission required. ' + (err && err.message));
          bigBtn.disabled = false;
        }
      });

      window.addEventListener('beforeunload', ()=>{
        try { dc && dc.send && dc.send({type:'hangup'}); } catch(e){}
        cleanup();
        try { localMic && localMic.getTracks().forEach(t=>t.stop()); } catch(e){}
      });

      // Compatibility shim: some code still calls updateStatus().
      // Map it to setProgress (if available) so it updates the progress UI instead of throwing.
      function updateStatus(text){
        try {
          if (typeof setProgress === 'function') {
            // Use a neutral progress value when unspecified
            setProgress(text, 50);
          } else {
            // fallback: update progress text element directly if present
            const el = document.getElementById('progressText');
            if (el) el.textContent = text;
            else console.log('status:', text);
          }
        } catch(e){
          console.log('updateStatus error', e && e.message);
        }
      }

      dbg('viewer page loaded. Ready.');
      updateStatus('Ready. Press the big CONNECT button (center) to begin.');
      setProgress('Ready. Press the big CONNECT button', 0);

      // Re-initialize zoom/pan (idempotent)
      if (!window.__ps_zoom_initialized) {
        window.__ps_zoom_initialized = true;
        const remoteEl = document.getElementById('remote');
        if (remoteEl) {
          let zoom = 1, panX = 0, panY = 0;
          const ZOOM_MIN = 1, ZOOM_MAX = 4, ZOOM_STEP = 0.12;
          const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
          const applyTransform = () => {
            document.documentElement.style.setProperty('--zoom', String(zoom));
            document.documentElement.style.setProperty('--pan-x', panX + 'px');
            document.documentElement.style.setProperty('--pan-y', panY + 'px');
          };
          const zoomTo = (newZoom, focalX = window.innerWidth/2, focalY = window.innerHeight/2) => {
            newZoom = clamp(newZoom, ZOOM_MIN, ZOOM_MAX);
            const prevZoom = zoom;
            const rect = remoteEl.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            const fx = focalX - cx;
            const fy = focalY - cy;
            panX = panX - fx * (newZoom/prevZoom - 1);
            panY = panY - fy * (newZoom/prevZoom - 1);
            zoom = newZoom;
            applyTransform();
          };

          // wheel (ctrl/cmd) zoom
          window.addEventListener('wheel', (e) => {
            if (!(e.ctrlKey || e.metaKey)) return;
            e.preventDefault();
            const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
            zoomTo(clamp(zoom + delta, ZOOM_MIN, ZOOM_MAX), e.clientX, e.clientY);
          }, { passive: false });

          // keyboard zoom
          window.addEventListener('keydown', (e) => {
            if (!(e.ctrlKey || e.metaKey)) return;
            if (e.key === '+' || e.key === '=') { e.preventDefault(); zoomTo(clamp(zoom + ZOOM_STEP, ZOOM_MIN, ZOOM_MAX)); }
            else if (e.key === '-') { e.preventDefault(); zoomTo(clamp(zoom - ZOOM_STEP, ZOOM_MIN, ZOOM_MAX)); }
            else if (e.key === '0') { e.preventDefault(); zoom = 1; panX = 0; panY = 0; applyTransform(); }
          });

          // pointer pan
          let dragging = false, last = {x:0,y:0};
          remoteEl.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            dragging = true;
            last.x = e.clientX; last.y = e.clientY;
            remoteEl.setPointerCapture && remoteEl.setPointerCapture(e.pointerId);
            remoteEl.style.cursor = 'grabbing';
          });
          window.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - last.x, dy = e.clientY - last.y;
            last.x = e.clientX; last.y = e.clientY;
            panX += dx; panY += dy;
            applyTransform();
          });
          window.addEventListener('pointerup', (e) => {
            if (!dragging) return;
            dragging = false;
            try { remoteEl.releasePointerCapture && remoteEl.releasePointerCapture(e.pointerId); } catch(e){}
            remoteEl.style.cursor = 'grab';
          });

          applyTransform();
        }
      }
    })();
  </script>
 </body>
 </html>